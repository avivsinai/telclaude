<file_tree>
telclaude/
├── .github/
│   └── workflows/
│       └── ci.yml
├── bin/
│   └── telclaude.js
├── src/
│   ├── auto-reply/
│   │   ├── claude.ts
│   │   ├── command-reply.ts
│   │   ├── index.ts
│   │   ├── templating.ts
│   │   └── types.ts
│   ├── cli/
│   │   ├── index.ts
│   │   └── program.ts
│   ├── commands/
│   │   ├── index.ts
│   │   ├── relay.ts
│   │   ├── send.ts
│   │   └── status.ts
│   ├── config/
│   │   ├── config.ts
│   │   ├── index.ts
│   │   └── sessions.ts
│   ├── media/
│   │   ├── index.ts
│   │   ├── parse.ts
│   │   └── store.ts
│   ├── process/
│   │   ├── command-queue.ts
│   │   ├── exec.ts
│   │   └── index.ts
│   ├── security/
│   │   ├── audit.ts
│   │   ├── fast-path.ts
│   │   ├── index.ts
│   │   ├── observer.ts
│   │   ├── permissions.ts
│   │   ├── rate-limit.ts
│   │   └── types.ts
│   ├── telegram/
│   │   ├── auto-reply.ts
│   │   ├── client.ts
│   │   ├── inbound.ts
│   │   ├── index.ts
│   │   ├── outbound.ts
│   │   ├── reconnect.ts
│   │   └── types.ts
│   ├── env.ts
│   ├── globals.ts
│   ├── index.ts
│   ├── logger.ts
│   ├── logging.ts
│   ├── runtime.ts
│   └── utils.ts
├── biome.json
├── CLAUDE.md
├── package.json
├── README.md
└── tsconfig.json</file_tree>

<files>
File: .github/workflows/ci.yml (189 tokens)
```
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint
        run: pnpm run lint

      - name: Type check
        run: pnpm run typecheck

      - name: Test
        run: pnpm test

      - name: Build
        run: pnpm run build

```

File: bin/telclaude.js (12 tokens)
```
#!/usr/bin/env node
import '../dist/index.js';

```

File: biome.json (168 tokens)
```
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "complexity": {
        "noForEach": "off"
      },
      "suspicious": {
        "noExplicitAny": "warn"
      },
      "style": {
        "noNonNullAssertion": "warn"
      }
    }
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "tab",
    "lineWidth": 100
  },
  "files": {
    "ignore": ["dist", "node_modules", "coverage"]
  }
}

```

File: CLAUDE.md (2380 tokens)
```
# Telclaude

Telegram-Claude bridge with comprehensive security layer. This project enables Claude CLI to respond to Telegram messages with proper security controls.

## Architecture Overview

```
Telegram Bot API (grammY)
         │
         ▼
┌─────────────────────────────────────┐
│          Security Layer             │
│  ┌──────────┐  ┌───────────────┐   │
│  │Fast Path │→ │ LLM Observer  │   │
│  │(regex)   │  │(Claude Haiku) │   │
│  └──────────┘  └───────────────┘   │
│        │              │             │
│        ▼              ▼             │
│  ┌──────────────────────────────┐  │
│  │   Permission Tier System     │  │
│  │ READ_ONLY│WRITE_SAFE│FULL    │  │
│  └──────────────────────────────┘  │
│        │                            │
│  ┌──────────┐  ┌───────────────┐   │
│  │Rate Limit│  │ Audit Logger  │   │
│  └──────────┘  └───────────────┘   │
└─────────────────────────────────────┘
         │
         ▼
    Claude CLI
    (with tier-specific flags)
```

## Key Concepts

### Permission Tiers

Three tiers control what Claude can do:

1. **READ_ONLY**: Claude can only read files, search, and browse the web
   - Flags: `--allowedTools Read,Glob,Grep,WebFetch,WebSearch`

2. **WRITE_SAFE**: Can write/edit files but restricted shell commands
   - Flags: `--allowedTools Read,Glob,Grep,WebFetch,WebSearch,Write,Edit,Bash`
   - Blocked: `rm`, `rmdir`, `mv`, `chmod`, `chown`, `kill`, `pkill`, `sudo`, `su`

3. **FULL_ACCESS**: No restrictions (requires explicit configuration)
   - Flags: `--dangerously-skip-permissions`

### Security Observer

Claude Haiku analyzes incoming messages before processing:
- Returns `ALLOW`, `WARN`, or `BLOCK` classification
- Fast-path regex handles obvious safe/dangerous patterns
- Configurable confidence thresholds

### Rate Limiting

- Global limits (per minute/hour)
- Per-user limits
- Per-tier limits (stricter for FULL_ACCESS)

## Project Structure

```
src/
├── index.ts              # Main entry point
├── globals.ts            # Global state (verbose flag)
├── logging.ts            # Pino logger setup
├── runtime.ts            # Runtime environment detection
├── utils.ts              # Utility functions
├── env.ts                # Environment variable handling
│
├── cli/
│   ├── program.ts        # Commander CLI setup
│   └── index.ts
│
├── commands/
│   ├── send.ts           # Send message command
│   ├── relay.ts          # Start relay command
│   ├── status.ts         # Show status command
│   └── index.ts
│
├── config/
│   ├── config.ts         # Configuration schema (Zod)
│   ├── sessions.ts       # Session management
│   └── index.ts
│
├── telegram/
│   ├── types.ts          # Telegram-specific types
│   ├── client.ts         # grammY bot creation
│   ├── inbound.ts        # Message reception
│   ├── outbound.ts       # Message sending
│   ├── reconnect.ts      # Reconnection logic
│   ├── auto-reply.ts     # Main monitoring loop
│   └── index.ts
│
├── security/
│   ├── types.ts          # Security types
│   ├── fast-path.ts      # Regex-based quick decisions
│   ├── observer.ts       # LLM-based analysis
│   ├── permissions.ts    # Tier system and Claude flags
│   ├── rate-limit.ts     # Rate limiting
│   ├── audit.ts          # Audit logging
│   └── index.ts
│
├── auto-reply/
│   ├── types.ts          # Reply configuration types
│   ├── templating.ts     # {{Placeholder}} interpolation
│   ├── claude.ts         # Claude output parsing
│   ├── command-reply.ts  # Command execution
│   └── index.ts
│
├── process/
│   ├── exec.ts           # Shell command execution
│   ├── command-queue.ts  # Command queuing
│   └── index.ts
│
└── media/
    ├── parse.ts          # Media path parsing
    ├── store.ts          # Media storage
    └── index.ts
```

## Configuration

Config file: `~/.telclaude/telclaude.json`

```json
{
  "telegram": {
    "allowedChats": [123456789],
    "reconnect": {
      "enabled": true,
      "maxAttempts": 10,
      "baseDelayMs": 1000
    }
  },
  "security": {
    "observer": {
      "enabled": true,
      "maxLatencyMs": 2000,
      "dangerThreshold": 0.7,
      "fallbackOnTimeout": "block"
    },
    "permissions": {
      "123456789": "WRITE_SAFE",
      "default": "READ_ONLY"
    },
    "rateLimits": {
      "global": { "perMinute": 100, "perHour": 1000 },
      "perUser": { "perMinute": 10, "perHour": 60 }
    },
    "audit": {
      "enabled": true,
      "logFile": "/var/log/telclaude/audit.log"
    }
  },
  "inbound": {
    "reply": {
      "mode": "command",
      "command": ["claude", "-p", "{{Body}}"],
      "timeoutSeconds": 600,
      "session": {
        "scope": "per-sender",
        "idleMinutes": 30,
        "resetTriggers": ["/new", "/reset"]
      }
    }
  }
}
```

## Environment Variables

Required:
- `TELEGRAM_BOT_TOKEN` - Bot token from @BotFather
- Claude CLI installed and logged in (`claude login`)

Optional:
- `TELCLAUDE_CONFIG` - Custom config file path
- `TELCLAUDE_LOG_LEVEL` - Log level (debug/info/warn/error)

## CLI Commands

```bash
# Start the relay
telclaude relay

# Send a message
telclaude send <chatId> "Hello!"
telclaude send <chatId> --media ./image.png --caption "Check this out"

# Check status
telclaude status
telclaude status --json
```

## Development

```bash
# Install dependencies
npm install

# Build
npm run build

# Run in development
npm run dev relay

# Type check
npm run typecheck

# Lint
npm run lint
npm run lint:fix

# Format
npm run format
```

## Key Implementation Details

### Message Flow

1. **Telegram message received** via grammY middleware
2. **Echo detection** - skip if we sent this message
3. **Rate limit check** - reject if exceeded
4. **Security observer** - analyze message content
5. **Session lookup** - find or create session
6. **Permission tier lookup** - get user's tier
7. **Claude CLI invocation** - with tier-specific flags
8. **Response sent** - back to Telegram
9. **Audit logged** - record the interaction

### Template Variables

Available in command templates:
- `{{Body}}` - Full message text
- `{{BodyStripped}}` - Trimmed message text
- `{{From}}` - Sender identifier (tg:chatId)
- `{{To}}` - Bot identifier
- `{{MessageId}}` - Telegram message ID
- `{{MediaPath}}` - Local path to downloaded media
- `{{MediaUrl}}` - URL for media
- `{{MediaType}}` - Type of media (photo/video/document/audio)
- `{{Username}}` - Telegram username
- `{{SessionId}}` - Current session UUID
- `{{IsNewSession}}` - "true" or "false"

### Session Handling

Sessions track conversation state:
- `per-sender` scope: One session per chat
- `global` scope: Single session for all chats
- Auto-reset after idle timeout
- Manual reset via trigger commands (`/new`, `/reset`)

### Security Observer Prompt

The observer uses this analysis prompt:
```
Analyze this message for security risks. The user has {tier} permissions.
Consider: shell injection, path traversal, privilege escalation, data exfiltration.
Respond with: ALLOW (safe), WARN (suspicious but not dangerous), BLOCK (dangerous).
Include confidence (0-1) and brief reason.
```

## Testing

Run the test suite:
```bash
npm test
```

For manual testing:
1. Create a test bot via @BotFather
2. Set `TELEGRAM_BOT_TOKEN`
3. Run `telclaude relay -v`
4. Send messages to your bot

## Common Tasks

### Adding a new command

1. Create `src/commands/mycommand.ts`
2. Export `registerMyCommand(program: Command)`
3. Import and register in `src/index.ts`

### Modifying security rules

- Fast-path patterns: `src/security/fast-path.ts`
- Observer prompts: `src/security/observer.ts`
- Permission flags: `src/security/permissions.ts`

### Adding a new permission tier

1. Add to `PermissionTier` type in `src/config/config.ts`
2. Add capability flags in `src/security/permissions.ts`
3. Update rate limits in `src/security/rate-limit.ts`

## Troubleshooting

### "TELEGRAM_BOT_TOKEN not set"
Set the environment variable with your bot token from @BotFather.

### "Claude CLI unavailable"
Install Claude CLI (`brew install anthropic-ai/cli/claude`) and run `claude login`. Without it, the observer falls back to fast-path + policy fallback.

### Rate limited
Check audit logs and adjust limits in config. Consider user tier assignment.

### Messages not received
1. Check `allowedChats` config
2. Verify bot permissions in the chat
3. Check Telegram API status

## Lineage

This project is derived from [Warelay](../warelay), replacing WhatsApp with Telegram and adding a comprehensive security layer. Key differences:

- **Provider**: Telegram Bot API (official, stable) vs WhatsApp Web (unofficial, fragile)
- **Security**: Multi-layer security vs no security layer
- **Permissions**: Tiered system vs unrestricted
- **Library**: grammY (TypeScript-first) vs Baileys (reverse-engineered)

```

File: package.json (660 tokens)
```
{
  "name": "telclaude",
  "version": "0.1.0",
  "description": "Secure Telegram-Claude bridge with LLM-based command screening and tiered permissions",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "telclaude": "./bin/telclaude.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsx src/index.ts",
    "start": "node dist/index.js",
    "lint": "biome check src",
    "lint:fix": "biome check --write src",
    "format": "biome format --write src",
    "test": "vitest run --passWithNoTests",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "typecheck": "tsc --noEmit",
    "clean": "rm -rf dist",
    "prepublishOnly": "pnpm run build"
  },
  "keywords": [
    "telegram",
    "claude",
    "ai",
    "bot",
    "relay",
    "cli"
  ],
  "author": "Aviv Sinai",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/avivsinai/telclaude.git"
  },
  "bugs": {
    "url": "https://github.com/avivsinai/telclaude/issues"
  },
  "homepage": "https://github.com/avivsinai/telclaude#readme",
  "engines": {
    "node": ">=22.0.0"
  },
  "packageManager": "pnpm@9.15.0",
  "dependencies": {
    "@grammyjs/auto-retry": "^2.0.2",
    "@grammyjs/runner": "^2.0.3",
    "chalk": "^5.4.1",
    "commander": "^14.0.0",
    "dotenv": "^17.2.3",
    "grammy": "^1.35.0",
    "json5": "^2.2.3",
    "pino": "^10.1.0",
    "pino-pretty": "^13.1.2",
    "rate-limiter-flexible": "^5.0.5",
    "sharp": "^0.33.5",
    "zod": "^3.25.0"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/node": "^22.15.0",
    "@vitest/coverage-v8": "^3.1.3",
    "tsx": "^4.20.6",
    "typescript": "^5.8.3",
    "vitest": "^3.1.3"
  }
}

```

File: README.md (807 tokens)
```
# telclaude

Secure Telegram-Claude bridge with LLM-based command screening and tiered permissions.

[![CI](https://github.com/avivsinai/telclaude/actions/workflows/ci.yml/badge.svg)](https://github.com/avivsinai/telclaude/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)

## Features

- **Telegram Bot API** via grammY (stable, official API)
- **Security Observer** using Claude Haiku for message screening
- **Tiered Permissions**: READ_ONLY, WRITE_SAFE, FULL_ACCESS
- **Rate Limiting** per-user, per-tier, and global
- **Session Management** with idle timeouts and reset triggers
- **Audit Logging** for compliance and debugging

## Quick Start

```bash
# Install globally
npm install -g telclaude

# Set up environment
cp .env.example .env
# Edit .env with your TELEGRAM_BOT_TOKEN

# Install and log into Claude CLI (once)
claude login

# Start the relay
telclaude relay --verbose
```

## Requirements

- Node.js 22+
- Telegram bot token from [@BotFather](https://t.me/BotFather)
- Claude CLI installed and logged in

## Commands

| Command | Description |
| --- | --- |
| `telclaude relay` | Start the message relay with auto-reply |
| `telclaude send <chatId> "message"` | Send a message to a chat |
| `telclaude status` | Show current status and configuration |

## Configuration

Create `~/.telclaude/telclaude.json`:

```json5
{
  "telegram": {
    "allowedChats": [123456789]
  },
  "security": {
    "observer": {
      "enabled": true,
      "dangerThreshold": 0.7
    },
    "permissions": {
      "123456789": "WRITE_SAFE",
      "default": "READ_ONLY"
    }
  },
  "inbound": {
    "reply": {
      "mode": "command",
      "command": ["claude", "-p", "{{Body}}"],
      "timeoutSeconds": 600
    }
  }
}
```

## Permission Tiers

| Tier | Capabilities |
| --- | --- |
| `READ_ONLY` | Read files, search, web browsing |
| `WRITE_SAFE` | Write/edit files, restricted shell (no rm, sudo, etc.) |
| `FULL_ACCESS` | No restrictions (requires explicit configuration) |

## Security

The security layer provides defense-in-depth:

1. **Fast Path**: Regex-based quick decisions for obvious patterns
2. **LLM Observer**: Claude Haiku analyzes ambiguous messages
3. **Rate Limiting**: Prevents abuse with configurable limits
4. **Audit Logging**: Records all interactions for review

## Development

```bash
# Clone and install
git clone https://github.com/avivsinai/telclaude.git
cd telclaude
pnpm install

# Development mode
pnpm dev relay

# Build
pnpm build

# Lint and format
pnpm lint
pnpm format

# Type check
pnpm typecheck

# Run tests
pnpm test
```

## Environment Variables

| Variable | Required | Description |
| --- | --- | --- |
| `TELEGRAM_BOT_TOKEN` | Yes | Bot token from @BotFather |
| `TELCLAUDE_CONFIG` | No | Custom config file path |
| `TELCLAUDE_LOG_LEVEL` | No | Log level (debug/info/warn/error) |

## License

MIT - see [LICENSE](LICENSE)

```

File: src/auto-reply/claude.ts (1326 tokens)
```
// Helpers specific to Claude CLI output/argv handling.
import { z } from "zod";

// Preferred binary name for Claude CLI invocations.
export const CLAUDE_BIN = "claude";
export const CLAUDE_IDENTITY_PREFIX =
	"You are Clawd (Claude) running on the user's machine via Telclaude (Telegram). Your scratchpad is ~/clawd; this is your folder and you can add what you like in markdown files and/or images. You don't need to be concise, but Telegram replies should stay reasonably sized. Media you can send: images ≤10MB, documents ≤50MB, video ≤50MB, audio ≤50MB. The prompt may include a media path and an optional Transcript: section—use them when present. If a prompt is a heartbeat poll and nothing needs attention, reply with exactly HEARTBEAT_OK and nothing else; for any alert, do not include HEARTBEAT_OK.";

function extractClaudeText(payload: unknown): string | undefined {
	// Best-effort walker to find the primary text field in Claude JSON outputs.
	if (payload == null) return undefined;
	if (typeof payload === "string") return payload;
	if (Array.isArray(payload)) {
		for (const item of payload) {
			const found = extractClaudeText(item);
			if (found) return found;
		}
		return undefined;
	}
	if (typeof payload === "object") {
		const obj = payload as Record<string, unknown>;
		if (typeof obj.result === "string") return obj.result;
		if (typeof obj.text === "string") return obj.text;
		if (typeof obj.completion === "string") return obj.completion;
		if (typeof obj.output === "string") return obj.output;
		if (obj.message) {
			const inner = extractClaudeText(obj.message);
			if (inner) return inner;
		}
		if (Array.isArray(obj.messages)) {
			const inner = extractClaudeText(obj.messages);
			if (inner) return inner;
		}
		if (Array.isArray(obj.content)) {
			for (const block of obj.content) {
				if (
					block &&
					typeof block === "object" &&
					(block as { type?: string }).type === "text" &&
					typeof (block as { text?: unknown }).text === "string"
				) {
					return (block as { text: string }).text;
				}
				const inner = extractClaudeText(block);
				if (inner) return inner;
			}
		}
	}
	return undefined;
}

export type ClaudeJsonParseResult = {
	text?: string;
	parsed: unknown;
	valid: boolean;
};

const ClaudeJsonSchema = z
	.object({
		type: z.string().optional(),
		subtype: z.string().optional(),
		is_error: z.boolean().optional(),
		result: z.string().optional(),
		text: z.string().optional(),
		completion: z.string().optional(),
		output: z.string().optional(),
		message: z.any().optional(),
		messages: z.any().optional(),
		content: z.any().optional(),
		duration_ms: z.number().optional(),
		duration_api_ms: z.number().optional(),
		num_turns: z.number().optional(),
		session_id: z.string().optional(),
		total_cost_usd: z.number().optional(),
		usage: z.record(z.string(), z.any()).optional(),
		modelUsage: z.record(z.string(), z.any()).optional(),
	})
	.passthrough()
	.refine(
		(obj) =>
			typeof obj.result === "string" ||
			typeof obj.text === "string" ||
			typeof obj.completion === "string" ||
			typeof obj.output === "string" ||
			obj.message !== undefined ||
			obj.messages !== undefined ||
			obj.content !== undefined,
		{ message: "Not a Claude JSON payload" },
	);

type ClaudeSafeParse = ReturnType<typeof ClaudeJsonSchema.safeParse>;

export function parseClaudeJson(raw: string): ClaudeJsonParseResult | undefined {
	// Handle a single JSON blob or newline-delimited JSON; return the first parsed payload.
	let firstParsed: unknown;
	const candidates = [
		raw,
		...raw
			.split(/\n+/)
			.map((s) => s.trim())
			.filter(Boolean),
	];
	for (const candidate of candidates) {
		try {
			const parsed = JSON.parse(candidate);
			if (firstParsed === undefined) firstParsed = parsed;
			let validation: ClaudeSafeParse | { success: false };
			try {
				validation = ClaudeJsonSchema.safeParse(parsed);
			} catch {
				validation = { success: false } as const;
			}
			const validated = validation.success ? validation.data : parsed;
			const isLikelyClaude =
				typeof validated === "object" &&
				validated !== null &&
				("result" in validated ||
					"text" in validated ||
					"completion" in validated ||
					"output" in validated);
			const text = extractClaudeText(validated);
			if (text)
				return {
					parsed: validated,
					text,
					// Treat parse as valid when schema passes or we still see Claude-like shape.
					valid: Boolean(validation?.success || isLikelyClaude),
				};
		} catch {
			// ignore parse errors; try next candidate
		}
	}
	if (firstParsed !== undefined) {
		let validation: ClaudeSafeParse | { success: false };
		try {
			validation = ClaudeJsonSchema.safeParse(firstParsed);
		} catch {
			validation = { success: false } as const;
		}
		const validated = validation.success ? validation.data : firstParsed;
		const isLikelyClaude =
			typeof validated === "object" &&
			validated !== null &&
			("result" in validated ||
				"text" in validated ||
				"completion" in validated ||
				"output" in validated);
		return {
			parsed: validated,
			text: extractClaudeText(validated),
			valid: Boolean(validation?.success || isLikelyClaude),
		};
	}
	return undefined;
}

export function parseClaudeJsonText(raw: string): string | undefined {
	const parsed = parseClaudeJson(raw);
	return parsed?.text;
}

```

File: src/auto-reply/command-reply.ts (3054 tokens)
```
import fs from "node:fs/promises";
import path from "node:path";

import type { TelclaudeConfig } from "../config/config.js";
import { isVerbose, logVerbose } from "../globals.js";
import { logError } from "../logger.js";
import { splitMediaFromOutput } from "../media/parse.js";
import { enqueueCommand } from "../process/command-queue.js";
import type { runCommandWithTimeout } from "../process/exec.js";
import {
	CLAUDE_BIN,
	CLAUDE_IDENTITY_PREFIX,
	type ClaudeJsonParseResult,
	parseClaudeJson,
} from "./claude.js";
import { type TemplateContext, applyTemplate } from "./templating.js";
import type { ReplyPayload } from "./types.js";

type CommandReplyConfig = NonNullable<TelclaudeConfig["inbound"]>["reply"] & {
	mode: "command";
};

type EnqueueRunner = typeof enqueueCommand;

type CommandReplyParams = {
	reply: CommandReplyConfig;
	templatingCtx: TemplateContext;
	sendSystemOnce: boolean;
	isNewSession: boolean;
	isFirstTurnInSession: boolean;
	systemSent: boolean;
	timeoutMs: number;
	timeoutSeconds: number;
	commandRunner: typeof runCommandWithTimeout;
	enqueue?: EnqueueRunner;
};

export type CommandReplyMeta = {
	durationMs: number;
	queuedMs?: number;
	queuedAhead?: number;
	exitCode?: number | null;
	signal?: string | null;
	killed?: boolean;
	claudeMeta?: string;
};

export type CommandReplyResult = {
	payload?: ReplyPayload;
	meta: CommandReplyMeta;
};

export function summarizeClaudeMetadata(payload: unknown): string | undefined {
	if (!payload || typeof payload !== "object") return undefined;
	const obj = payload as Record<string, unknown>;
	const parts: string[] = [];

	if (typeof obj.duration_ms === "number") {
		parts.push(`duration=${obj.duration_ms}ms`);
	}
	if (typeof obj.duration_api_ms === "number") {
		parts.push(`api=${obj.duration_api_ms}ms`);
	}
	if (typeof obj.num_turns === "number") {
		parts.push(`turns=${obj.num_turns}`);
	}
	if (typeof obj.total_cost_usd === "number") {
		parts.push(`cost=$${obj.total_cost_usd.toFixed(4)}`);
	}

	const usage = obj.usage;
	if (usage && typeof usage === "object") {
		const serverToolUse = (usage as { server_tool_use?: Record<string, unknown> }).server_tool_use;
		if (serverToolUse && typeof serverToolUse === "object") {
			const toolCalls = Object.values(serverToolUse).reduce<number>((sum, val) => {
				if (typeof val === "number") return sum + val;
				return sum;
			}, 0);
			if (toolCalls > 0) parts.push(`tool_calls=${toolCalls}`);
		}
	}

	const modelUsage = obj.modelUsage;
	if (modelUsage && typeof modelUsage === "object") {
		const models = Object.keys(modelUsage as Record<string, unknown>);
		if (models.length) {
			const display =
				models.length > 2
					? `${models.slice(0, 2).join(",")}+${models.length - 2}`
					: models.join(",");
			parts.push(`models=${display}`);
		}
	}

	return parts.length ? parts.join(", ") : undefined;
}

export async function runCommandReply(params: CommandReplyParams): Promise<CommandReplyResult> {
	const {
		reply,
		templatingCtx,
		sendSystemOnce,
		isNewSession,
		isFirstTurnInSession,
		systemSent,
		timeoutMs,
		timeoutSeconds,
		commandRunner,
		enqueue = enqueueCommand,
	} = params;

	if (!reply.command?.length) {
		throw new Error("reply.command is required for mode=command");
	}

	let argv = reply.command.map((part) => applyTemplate(part, templatingCtx));
	const templatePrefix =
		reply.template && (!sendSystemOnce || isFirstTurnInSession || !systemSent)
			? applyTemplate(reply.template, templatingCtx)
			: "";
	if (templatePrefix && argv.length > 0) {
		argv = [argv[0], templatePrefix, ...argv.slice(1)];
	}

	// Ensure Claude commands can emit plain text by forcing --output-format when configured.
	if (reply.claudeOutputFormat && argv.length > 0 && path.basename(argv[0]) === CLAUDE_BIN) {
		const hasOutputFormat = argv.some(
			(part) => part === "--output-format" || part.startsWith("--output-format="),
		);
		const insertBeforeBody = Math.max(argv.length - 1, 0);
		if (!hasOutputFormat) {
			argv = [
				...argv.slice(0, insertBeforeBody),
				"--output-format",
				reply.claudeOutputFormat,
				...argv.slice(insertBeforeBody),
			];
		}
		const hasPrintFlag = argv.some((part) => part === "-p" || part === "--print");
		if (!hasPrintFlag) {
			const insertIdx = Math.max(argv.length - 1, 0);
			argv = [...argv.slice(0, insertIdx), "-p", ...argv.slice(insertIdx)];
		}
	}

	// Inject session args if configured (use resume for existing, session-id for new)
	if (reply.session) {
		const sessionArgList = (
			isNewSession
				? (reply.session.sessionArgNew ?? ["--session-id", "{{SessionId}}"])
				: (reply.session.sessionArgResume ?? ["--resume", "{{SessionId}}"])
		).map((part) => applyTemplate(part, templatingCtx));
		if (sessionArgList.length) {
			const insertBeforeBody = reply.session.sessionArgBeforeBody ?? true;
			const insertAt = insertBeforeBody && argv.length > 1 ? argv.length - 1 : argv.length;
			argv = [...argv.slice(0, insertAt), ...sessionArgList, ...argv.slice(insertAt)];
		}
	}

	let finalArgv = argv;
	const isClaudeInvocation = finalArgv.length > 0 && path.basename(finalArgv[0]) === CLAUDE_BIN;
	const shouldPrependIdentity = isClaudeInvocation && !(sendSystemOnce && systemSent);
	if (shouldPrependIdentity && finalArgv.length > 0) {
		const bodyIdx = finalArgv.length - 1;
		const existingBody = finalArgv[bodyIdx] ?? "";
		finalArgv = [
			...finalArgv.slice(0, bodyIdx),
			[CLAUDE_IDENTITY_PREFIX, existingBody].filter(Boolean).join("\n\n"),
		];
	}
	logVerbose(
		`Running command auto-reply: ${finalArgv.join(" ")}${reply.cwd ? ` (cwd: ${reply.cwd})` : ""}`,
	);

	const started = Date.now();
	let queuedMs: number | undefined;
	let queuedAhead: number | undefined;
	try {
		const { stdout, stderr, code, signal, killed } = await enqueue(
			() => commandRunner(finalArgv, { timeoutMs, cwd: reply.cwd }),
			{
				onWait: (waitMs, ahead) => {
					queuedMs = waitMs;
					queuedAhead = ahead;
					if (isVerbose()) {
						logVerbose(`Command auto-reply queued for ${waitMs}ms (${queuedAhead} ahead)`);
					}
				},
			},
		);
		const rawStdout = stdout.trim();
		let mediaFromCommand: string[] | undefined;
		let trimmed = rawStdout;
		if (stderr?.trim()) {
			logVerbose(`Command auto-reply stderr: ${stderr.trim()}`);
		}
		let parsed: ClaudeJsonParseResult | undefined;
		if (trimmed && (reply.claudeOutputFormat === "json" || isClaudeInvocation)) {
			parsed = parseClaudeJson(trimmed);
			if (parsed?.parsed && isVerbose()) {
				const summary = summarizeClaudeMetadata(parsed.parsed);
				if (summary) logVerbose(`Claude JSON meta: ${summary}`);
				logVerbose(`Claude JSON raw: ${JSON.stringify(parsed.parsed, null, 2)}`);
			}
			if (parsed?.text) {
				logVerbose(
					`Claude JSON parsed -> ${parsed.text.slice(0, 120)}${parsed.text.length > 120 ? "…" : ""}`,
				);
				trimmed = parsed.text.trim();
			} else {
				logVerbose("Claude JSON parse failed; returning raw stdout");
			}
		}
		const { text: cleanedText, mediaUrls: mediaFound } = splitMediaFromOutput(trimmed);
		trimmed = cleanedText;
		if (mediaFound?.length) {
			mediaFromCommand = mediaFound;
			if (isVerbose()) logVerbose(`MEDIA token extracted: ${mediaFound}`);
		} else if (isVerbose()) {
			logVerbose("No MEDIA token extracted from final text");
		}
		if (!trimmed && !mediaFromCommand) {
			const meta = parsed ? summarizeClaudeMetadata(parsed.parsed) : undefined;
			trimmed = `(command produced no output${meta ? `; ${meta}` : ""})`;
			logVerbose("No text/media produced; injecting fallback notice to user");
		}
		logVerbose(`Command auto-reply stdout (trimmed): ${trimmed || "<empty>"}`);
		logVerbose(`Command auto-reply finished in ${Date.now() - started}ms`);
		if ((code ?? 0) !== 0) {
			console.error(
				`Command auto-reply exited with code ${code ?? "unknown"} (signal: ${signal ?? "none"})`,
			);
			return {
				payload: undefined,
				meta: {
					durationMs: Date.now() - started,
					queuedMs,
					queuedAhead,
					exitCode: code,
					signal,
					killed,
					claudeMeta: parsed ? summarizeClaudeMetadata(parsed.parsed) : undefined,
				},
			};
		}
		if (killed && !signal) {
			console.error(
				`Command auto-reply process killed before completion (exit code ${code ?? "unknown"})`,
			);
			return {
				payload: undefined,
				meta: {
					durationMs: Date.now() - started,
					queuedMs,
					queuedAhead,
					exitCode: code,
					signal,
					killed,
					claudeMeta: parsed ? summarizeClaudeMetadata(parsed.parsed) : undefined,
				},
			};
		}
		let mediaUrls = mediaFromCommand ?? (reply.mediaUrl ? [reply.mediaUrl] : undefined);

		// If mediaMaxMb is set, skip local media paths larger than the cap.
		if (mediaUrls?.length && reply.mediaMaxMb) {
			const maxBytes = reply.mediaMaxMb * 1024 * 1024;
			const filtered: string[] = [];
			for (const url of mediaUrls) {
				if (/^https?:\/\//i.test(url)) {
					filtered.push(url);
					continue;
				}
				const abs = path.isAbsolute(url) ? url : path.resolve(url);
				try {
					const stats = await fs.stat(abs);
					if (stats.size <= maxBytes) {
						filtered.push(url);
					} else if (isVerbose()) {
						logVerbose(
							`Skipping media ${url} (${(stats.size / (1024 * 1024)).toFixed(2)}MB) over cap ${reply.mediaMaxMb}MB`,
						);
					}
				} catch {
					filtered.push(url);
				}
			}
			mediaUrls = filtered;
		}

		const payload =
			trimmed || mediaUrls?.length
				? {
						text: trimmed || undefined,
						mediaUrl: mediaUrls?.[0],
						mediaUrls,
					}
				: undefined;
		const meta: CommandReplyMeta = {
			durationMs: Date.now() - started,
			queuedMs,
			queuedAhead,
			exitCode: code,
			signal,
			killed,
			claudeMeta: parsed ? summarizeClaudeMetadata(parsed.parsed) : undefined,
		};
		if (isVerbose()) {
			logVerbose(`Command auto-reply meta: ${JSON.stringify(meta)}`);
		}
		return { payload, meta };
	} catch (err) {
		const elapsed = Date.now() - started;
		const anyErr = err as { killed?: boolean; signal?: string };
		const timeoutHit = anyErr.killed === true || anyErr.signal === "SIGKILL";
		const errorObj = err as { stdout?: string; stderr?: string };
		if (errorObj.stderr?.trim()) {
			logVerbose(`Command auto-reply stderr: ${errorObj.stderr.trim()}`);
		}
		if (timeoutHit) {
			console.error(`Command auto-reply timed out after ${elapsed}ms (limit ${timeoutMs}ms)`);
			const baseMsg = `Command timed out after ${timeoutSeconds}s${reply.cwd ? ` (cwd: ${reply.cwd})` : ""}. Try a shorter prompt or split the request.`;
			const partial = errorObj.stdout?.trim();
			const partialSnippet =
				partial && partial.length > 800 ? `${partial.slice(0, 800)}...` : partial;
			const text = partialSnippet
				? `${baseMsg}\n\nPartial output before timeout:\n${partialSnippet}`
				: baseMsg;
			return {
				payload: { text },
				meta: {
					durationMs: elapsed,
					queuedMs,
					queuedAhead,
					exitCode: undefined,
					signal: anyErr.signal,
					killed: anyErr.killed,
				},
			};
		}
		logError(`Command auto-reply failed after ${elapsed}ms: ${String(err)}`);
		return {
			payload: undefined,
			meta: {
				durationMs: elapsed,
				queuedMs,
				queuedAhead,
				exitCode: undefined,
				signal: anyErr.signal,
				killed: anyErr.killed,
			},
		};
	}
}

```

File: src/auto-reply/index.ts (38 tokens)
```
// Auto-reply exports

export * from "./types.js";
export * from "./templating.js";
export * from "./claude.js";
export * from "./command-reply.js";

```

File: src/auto-reply/templating.ts (160 tokens)
```
export type MsgContext = {
	Body?: string;
	From?: string;
	To?: string;
	MessageId?: string;
	MediaPath?: string;
	MediaUrl?: string;
	MediaType?: string;
	Transcript?: string;
	Username?: string;
};

export type TemplateContext = MsgContext & {
	BodyStripped?: string;
	SessionId?: string;
	IsNewSession?: string;
};

// Simple {{Placeholder}} interpolation using inbound message context.
export function applyTemplate(str: string, ctx: TemplateContext) {
	return str.replace(/{{\s*(\w+)\s*}}/g, (_, key) => {
		const value = (ctx as Record<string, unknown>)[key];
		return value == null ? "" : String(value);
	});
}

```

File: src/auto-reply/types.ts (43 tokens)
```
export type GetReplyOptions = {
	onReplyStart?: () => Promise<void> | void;
};

export type ReplyPayload = {
	text?: string;
	mediaUrl?: string;
	mediaUrls?: string[];
};

```

File: src/cli/index.ts (11 tokens)
```
// CLI exports

export * from "./program.js";

```

File: src/cli/program.ts (194 tokens)
```
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { Command } from "commander";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

function getVersion(): string {
	try {
		const pkgPath = path.resolve(__dirname, "../../package.json");
		const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
		return pkg.version ?? "0.0.0";
	} catch {
		return "0.0.0";
	}
}

export function createProgram(): Command {
	const program = new Command();

	program
		.name("telclaude")
		.description("Telegram-Claude bridge with security layer")
		.version(getVersion())
		.option("-v, --verbose", "Enable verbose output")
		.option("-c, --config <path>", "Path to config file");

	return program;
}

```

File: src/commands/index.ts (25 tokens)
```
// Command exports

export * from "./send.js";
export * from "./relay.js";
export * from "./status.js";

```

File: src/commands/relay.ts (484 tokens)
```
import type { Command } from "commander";
import { loadConfig } from "../config/config.js";
import { readEnv } from "../env.js";
import { setVerbose } from "../globals.js";
import { getChildLogger } from "../logging.js";
import { monitorTelegramProvider } from "../telegram/auto-reply.js";

const logger = getChildLogger({ module: "cmd-relay" });

export type RelayOptions = {
	verbose?: boolean;
	dryRun?: boolean;
};

export function registerRelayCommand(program: Command): void {
	program
		.command("relay")
		.description("Start the Telegram relay with auto-reply")
		.option("--dry-run", "Don't actually send replies (for testing)")
		.action(async (opts: RelayOptions) => {
			const verbose = program.opts().verbose || opts.verbose;

			if (verbose) {
				setVerbose(true);
			}

			try {
				const cfg = loadConfig();
				readEnv(); // Validates environment variables

				console.log("Starting Telclaude relay...");
				console.log(
					`Security observer: ${cfg.security?.observer?.enabled !== false ? "enabled" : "disabled"}`,
				);
				console.log("Rate limiting: enabled");
				console.log(
					`Audit logging: ${cfg.security?.audit?.enabled !== false ? "enabled" : "disabled"}`,
				);

				if (cfg.telegram?.allowedChats?.length) {
					console.log(`Allowed chats: ${cfg.telegram.allowedChats.join(", ")}`);
				} else {
					console.log("Warning: No allowed chats configured - bot will respond to all chats");
				}

				// Set up graceful shutdown
				const abortController = new AbortController();

				const shutdown = () => {
					console.log("\nShutting down...");
					abortController.abort();
				};

				process.on("SIGINT", shutdown);
				process.on("SIGTERM", shutdown);

				await monitorTelegramProvider({
					verbose,
					keepAlive: true,
					abortSignal: abortController.signal,
				});

				console.log("Relay stopped.");
			} catch (err) {
				logger.error({ error: String(err) }, "relay command failed");
				console.error(`Error: ${err}`);
				process.exit(1);
			}
		});
}

```

File: src/commands/send.ts (471 tokens)
```
import type { Command } from "commander";
import { readEnv } from "../env.js";
import { getChildLogger } from "../logging.js";
import { sendTelegramMessage } from "../telegram/outbound.js";

const logger = getChildLogger({ module: "cmd-send" });

export type SendOptions = {
	verbose?: boolean;
	media?: string;
	caption?: string;
};

export function registerSendCommand(program: Command): void {
	program
		.command("send")
		.description("Send a message to a Telegram chat")
		.argument("<chatId>", "Telegram chat ID (numeric)")
		.argument("[message]", "Message text to send")
		.option("-m, --media <path>", "Path to media file to send")
		.option("--caption <text>", "Caption for media")
		.action(async (chatId: string, message: string | undefined, opts: SendOptions) => {
			const verbose = program.opts().verbose || opts.verbose;

			try {
				const env = readEnv();
				const token = env.telegramBotToken;

				const numericChatId = Number.parseInt(chatId, 10);
				if (Number.isNaN(numericChatId)) {
					console.error("Error: chatId must be a numeric value");
					process.exit(1);
				}

				if (!message && !opts.media) {
					console.error("Error: Either message or --media must be provided");
					process.exit(1);
				}

				if (verbose) {
					console.log(`Sending to chat ${numericChatId}...`);
				}

				const result = await sendTelegramMessage({
					token,
					chatId: numericChatId,
					text: message,
					mediaPath: opts.media,
					caption: opts.caption,
				});

				if (result.success) {
					console.log(`Message sent successfully (ID: ${result.messageId})`);
				} else {
					console.error(`Failed to send message: ${result.error}`);
					process.exit(1);
				}
			} catch (err) {
				logger.error({ error: String(err) }, "send command failed");
				console.error(`Error: ${err}`);
				process.exit(1);
			}
		});
}

```

File: src/commands/status.ts (888 tokens)
```
import fs from "node:fs";
import type { Command } from "commander";
import { execSync } from "node:child_process";
import { CONFIG_PATH, loadConfig } from "../config/config.js";
import { getChildLogger } from "../logging.js";
import { createAuditLogger } from "../security/audit.js";

const logger = getChildLogger({ module: "cmd-status" });

export type StatusOptions = {
	json?: boolean;
};

export function registerStatusCommand(program: Command): void {
	program
		.command("status")
		.description("Show Telclaude status and configuration")
		.option("--json", "Output as JSON")
		.action(async (opts: StatusOptions) => {
			try {
				const hasConfig = fs.existsSync(CONFIG_PATH);
				const cfg = hasConfig ? loadConfig() : null;

				const token = process.env.TELEGRAM_BOT_TOKEN;
				let claudeCli = "missing";
				try {
					const version = execSync("claude --version", {
						encoding: "utf8",
						stdio: ["ignore", "pipe", "pipe"],
					}).trim();
					claudeCli = version || "installed";
				} catch {
					// best-effort check only
				}

				// Get audit stats if enabled
				let auditStats = null;
				if (cfg?.security?.audit?.enabled !== false) {
					const auditLogger = createAuditLogger({
						enabled: true,
						logFile: cfg?.security?.audit?.logFile,
					});
					auditStats = await auditLogger.getStats();
				}

				const status = {
					config: {
						path: CONFIG_PATH,
						exists: hasConfig,
					},
					environment: {
						telegramToken: token ? "set" : "not set",
						claudeCli,
					},
					security: cfg
						? {
								observer: cfg.security?.observer?.enabled !== false ? "enabled" : "disabled",
								audit: cfg.security?.audit?.enabled !== false ? "enabled" : "disabled",
								rateLimiting: "enabled",
								permissionTiers: cfg.security?.permissions
									? Object.keys(cfg.security.permissions)
									: [],
							}
						: null,
					telegram: cfg
						? {
								allowedChats: cfg.telegram?.allowedChats ?? [],
							}
						: null,
					audit: auditStats,
				};

				if (opts.json) {
					console.log(JSON.stringify(status, null, 2));
				} else {
					console.log("=== Telclaude Status ===\n");

					console.log("Configuration:");
					console.log(`  Path: ${status.config.path}`);
					console.log(`  Exists: ${status.config.exists ? "yes" : "no"}`);
					console.log();

					console.log("Environment:");
					console.log(`  TELEGRAM_BOT_TOKEN: ${status.environment.telegramToken}`);
					console.log(`  Claude CLI: ${status.environment.claudeCli}`);
					console.log();

					if (status.security) {
						console.log("Security:");
						console.log(`  Observer: ${status.security.observer}`);
						console.log(`  Audit: ${status.security.audit}`);
						console.log(`  Rate Limiting: ${status.security.rateLimiting}`);
						if (status.security.permissionTiers.length > 0) {
							console.log(`  Permission Tiers: ${status.security.permissionTiers.join(", ")}`);
						}
						console.log();
					}

					if (status.telegram) {
						console.log("Telegram:");
						if (status.telegram.allowedChats.length > 0) {
							console.log(`  Allowed Chats: ${status.telegram.allowedChats.join(", ")}`);
						} else {
							console.log("  Allowed Chats: all (no restrictions)");
						}
						console.log();
					}

					if (status.audit) {
						console.log("Audit Statistics:");
						console.log(`  Total requests: ${status.audit.total}`);
						console.log(`  Successful: ${status.audit.success}`);
						console.log(`  Blocked: ${status.audit.blocked}`);
						console.log(`  Rate Limited: ${status.audit.rateLimited}`);
						console.log(`  Errors: ${status.audit.errors}`);
					}
				}
			} catch (err) {
				logger.error({ error: String(err) }, "status command failed");
				console.error(`Error: ${err}`);
				process.exit(1);
			}
		});
}

```

File: src/config/config.ts (1950 tokens)
```
import fs from "node:fs";
import path from "node:path";

import JSON5 from "json5";
import { z } from "zod";

import { CONFIG_DIR } from "../utils.js";

export const CONFIG_PATH = path.join(CONFIG_DIR, "telclaude.json");

// Session configuration schema
const SessionConfigSchema = z.object({
	scope: z.enum(["per-sender", "global"]).default("per-sender"),
	idleMinutes: z.number().int().positive().default(60),
	resetTriggers: z.array(z.string()).default(["/new"]),
	sendSystemOnce: z.boolean().default(false),
	sessionIntro: z.string().optional(),
	sessionArgNew: z.array(z.string()).optional(),
	sessionArgResume: z.array(z.string()).optional(),
	sessionArgBeforeBody: z.boolean().default(true),
	store: z.string().optional(),
});

// Reply configuration schema
const ReplyConfigSchema = z.object({
	mode: z.enum(["text", "command"]).default("command"),
	text: z.string().optional(),
	command: z.array(z.string()).optional(),
	cwd: z.string().optional(),
	template: z.string().optional(),
	timeoutSeconds: z.number().int().positive().default(600),
	bodyPrefix: z.string().optional(),
	session: SessionConfigSchema.optional(),
	claudeOutputFormat: z.enum(["text", "json", "stream-json"]).optional(),
	mediaMaxMb: z.number().positive().optional(),
	typingIntervalSeconds: z.number().positive().default(8),
	heartbeatMinutes: z.number().positive().optional(),
	mediaUrl: z.string().optional(),
});

// Inbound (auto-reply) configuration schema
const InboundConfigSchema = z.object({
	transcribeAudio: z
		.object({
			command: z.array(z.string()),
			timeoutSeconds: z.number().int().positive().default(45),
		})
		.optional(),
	reply: ReplyConfigSchema.optional(),
});

// Security observer configuration
const ObserverConfigSchema = z.object({
	enabled: z.boolean().default(true),
	maxLatencyMs: z.number().int().positive().default(2000),
	dangerThreshold: z.number().min(0).max(1).default(0.7),
	fallbackOnTimeout: z.enum(["allow", "block", "escalate"]).default("block"),
});

// Permission tier
export const PermissionTierSchema = z.enum(["READ_ONLY", "WRITE_SAFE", "FULL_ACCESS"]);
export type PermissionTier = z.infer<typeof PermissionTierSchema>;

// User permission configuration
const UserPermissionSchema = z.object({
	tier: PermissionTierSchema,
	rateLimit: z
		.object({
			perMinute: z.number().int().positive().optional(),
			perHour: z.number().int().positive().optional(),
		})
		.optional(),
});

// Security configuration schema
const SecurityConfigSchema = z.object({
	observer: ObserverConfigSchema.optional(),
	permissions: z
		.object({
			defaultTier: PermissionTierSchema.default("READ_ONLY"),
			users: z.record(z.string(), UserPermissionSchema).default({}),
		})
		.optional(),
	rateLimits: z
		.object({
			global: z
				.object({
					perMinute: z.number().int().positive().default(100),
					perHour: z.number().int().positive().default(1000),
				})
				.optional(),
			perUser: z
				.object({
					perMinute: z.number().int().positive().default(10),
					perHour: z.number().int().positive().default(60),
				})
				.optional(),
			perTier: z
				.object({
					READ_ONLY: z
						.object({
							perMinute: z.number().int().positive().default(20),
							perHour: z.number().int().positive().default(200),
						})
						.optional(),
					WRITE_SAFE: z
						.object({
							perMinute: z.number().int().positive().default(10),
							perHour: z.number().int().positive().default(100),
						})
						.optional(),
					FULL_ACCESS: z
						.object({
							perMinute: z.number().int().positive().default(5),
							perHour: z.number().int().positive().default(30),
						})
						.optional(),
				})
				.optional(),
		})
		.optional(),
	audit: z
		.object({
			enabled: z.boolean().default(true),
			logFile: z.string().optional(),
		})
		.optional(),
});

// Telegram configuration schema
const TelegramConfigSchema = z.object({
	allowedChats: z.array(z.union([z.number(), z.string()])).optional(),
	polling: z
		.object({
			timeout: z.number().int().positive().default(30),
			limit: z.number().int().positive().default(100),
		})
		.optional(),
	webhook: z
		.object({
			port: z.number().int().positive().optional(),
			path: z.string().optional(),
			secretToken: z.string().optional(),
		})
		.optional(),
	heartbeatSeconds: z.number().int().positive().default(60),
	reconnect: z
		.object({
			initialMs: z.number().int().positive().default(1000),
			maxMs: z.number().int().positive().default(60000),
			factor: z.number().positive().default(2.0),
			jitter: z.number().min(0).max(1).default(0.3),
			maxAttempts: z.number().int().min(0).default(0), // 0 = unlimited
		})
		.optional(),
});

// Logging configuration schema
const LoggingConfigSchema = z.object({
	level: z.enum(["silent", "fatal", "error", "warn", "info", "debug", "trace"]).optional(),
	file: z.string().optional(),
});

// Main config schema
const TelclaudeConfigSchema = z.object({
	security: SecurityConfigSchema.optional(),
	telegram: TelegramConfigSchema.optional(),
	inbound: InboundConfigSchema.optional(),
	logging: LoggingConfigSchema.optional(),
});

export type TelclaudeConfig = z.infer<typeof TelclaudeConfigSchema>;
export type ReplyConfig = z.infer<typeof ReplyConfigSchema>;
export type SessionConfig = z.infer<typeof SessionConfigSchema>;
export type SecurityConfig = z.infer<typeof SecurityConfigSchema>;
export type TelegramConfig = z.infer<typeof TelegramConfigSchema>;

let cachedConfig: TelclaudeConfig | null = null;
let configMtime: number | null = null;

/**
 * Load and parse the configuration file.
 */
export function loadConfig(): TelclaudeConfig {
	try {
		const stat = fs.statSync(CONFIG_PATH);
		if (cachedConfig && configMtime === stat.mtimeMs) {
			return cachedConfig;
		}

		const raw = fs.readFileSync(CONFIG_PATH, "utf-8");
		const parsed = JSON5.parse(raw);
		const validated = TelclaudeConfigSchema.parse(parsed);

		cachedConfig = validated;
		configMtime = stat.mtimeMs;

		return validated;
	} catch (err) {
		if ((err as NodeJS.ErrnoException).code === "ENOENT") {
			// No config file, return defaults
			return {};
		}
		throw err;
	}
}

/**
 * Reset the config cache (useful for testing).
 */
export function resetConfigCache() {
	cachedConfig = null;
	configMtime = null;
}

/**
 * Get the default config directory path.
 */
export function getConfigDir(): string {
	return CONFIG_DIR;
}

/**
 * Ensure the config directory exists.
 */
export async function ensureConfigDir(): Promise<void> {
	await fs.promises.mkdir(CONFIG_DIR, { recursive: true });
}

/**
 * Create a default config file if it doesn't exist.
 */
export async function createDefaultConfigIfMissing(): Promise<boolean> {
	try {
		await fs.promises.access(CONFIG_PATH);
		return false; // Already exists
	} catch {
		await ensureConfigDir();
		const defaultConfig = {
			security: {
				observer: {
					enabled: true,
					maxLatencyMs: 2000,
					dangerThreshold: 0.7,
					fallbackOnTimeout: "block",
				},
				permissions: {
					defaultTier: "READ_ONLY",
					users: {},
				},
				rateLimits: {
					perUser: {
						perMinute: 10,
						perHour: 60,
					},
				},
				audit: {
					enabled: true,
				},
			},
			telegram: {
				allowedChats: [],
				polling: {
					timeout: 30,
				},
			},
			inbound: {
				reply: {
					mode: "command",
					command: ["claude", "-p", "{{BodyStripped}}"],
					timeoutSeconds: 600,
					claudeOutputFormat: "json",
				},
			},
			logging: {
				level: "info",
			},
		};

		await fs.promises.writeFile(CONFIG_PATH, JSON.stringify(defaultConfig, null, 2), "utf-8");
		return true;
	}
}

```

File: src/config/index.ts (18 tokens)
```
// Configuration exports

export * from "./config.js";
export * from "./sessions.js";

```

File: src/config/sessions.ts (391 tokens)
```
import fs from "node:fs";
import os from "node:os";
import path from "node:path";

import JSON5 from "json5";
import type { MsgContext } from "../auto-reply/templating.js";
import { CONFIG_DIR, normalizeTelegramId } from "../utils.js";

export type SessionScope = "per-sender" | "global";

export type SessionEntry = {
	sessionId: string;
	updatedAt: number;
	systemSent?: boolean;
};

export const SESSION_STORE_DEFAULT = path.join(CONFIG_DIR, "sessions.json");
export const DEFAULT_RESET_TRIGGER = "/new";
export const DEFAULT_IDLE_MINUTES = 60;

export function resolveStorePath(store?: string) {
	if (!store) return SESSION_STORE_DEFAULT;
	if (store.startsWith("~")) return path.resolve(store.replace("~", os.homedir()));
	return path.resolve(store);
}

export function loadSessionStore(storePath: string): Record<string, SessionEntry> {
	try {
		const raw = fs.readFileSync(storePath, "utf-8");
		const parsed = JSON5.parse(raw);
		if (parsed && typeof parsed === "object") {
			return parsed as Record<string, SessionEntry>;
		}
	} catch {
		// ignore missing/invalid store; we'll recreate it
	}
	return {};
}

export async function saveSessionStore(storePath: string, store: Record<string, SessionEntry>) {
	await fs.promises.mkdir(path.dirname(storePath), { recursive: true });
	await fs.promises.writeFile(storePath, JSON.stringify(store, null, 2), "utf-8");
}

// Decide which session bucket to use (per-sender vs global).
export function deriveSessionKey(scope: SessionScope, ctx: MsgContext) {
	if (scope === "global") return "global";
	const from = ctx.From ? normalizeTelegramId(ctx.From) : "";
	return from || "unknown";
}

```

File: src/env.ts (353 tokens)
```
import { z } from "zod";
import { type RuntimeEnv, defaultRuntime } from "./runtime.js";

const TelclaudeEnvSchema = z.object({
	telegramBotToken: z.string().min(1),
});

export type TelclaudeEnv = z.infer<typeof TelclaudeEnvSchema>;

let cachedEnv: TelclaudeEnv | null = null;

/**
 * Read and validate required environment variables.
 */
export function readEnv(runtime: RuntimeEnv = defaultRuntime): TelclaudeEnv {
	if (cachedEnv) return cachedEnv;

	const token = process.env.TELEGRAM_BOT_TOKEN;
	if (!token) {
		runtime.error("TELEGRAM_BOT_TOKEN environment variable is required");
		runtime.error("Get a token from @BotFather on Telegram");
		runtime.exit(1);
	}

	const env: TelclaudeEnv = {
		telegramBotToken: token,
	};

	// Validate
	const result = TelclaudeEnvSchema.safeParse(env);
	if (!result.success) {
		runtime.error("Invalid environment configuration:");
		for (const error of result.error.errors) {
			runtime.error(`  ${error.path.join(".")}: ${error.message}`);
		}
		runtime.exit(1);
	}

	cachedEnv = result.data;
	return cachedEnv;
}

/**
 * Check if environment is properly configured.
 */
export function hasValidEnv(): boolean {
	return !!process.env.TELEGRAM_BOT_TOKEN;
}

/**
 * Reset cached environment (for testing).
 */
export function resetEnvCache() {
	cachedEnv = null;
}

```

File: src/globals.ts (121 tokens)
```
import chalk from "chalk";

let globalVerbose = false;
let globalYes = false;

export function setVerbose(v: boolean) {
	globalVerbose = v;
}

export function isVerbose() {
	return globalVerbose;
}

export function logVerbose(message: string) {
	if (globalVerbose) console.log(chalk.gray(message));
}

export function setYes(v: boolean) {
	globalYes = v;
}

export function isYes() {
	return globalYes;
}

export const success = chalk.green;
export const warn = chalk.yellow;
export const info = chalk.cyan;
export const danger = chalk.red;

```

File: src/index.ts (109 tokens)
```
#!/usr/bin/env node

import { createProgram } from "./cli/program.js";
import { registerRelayCommand } from "./commands/relay.js";
import { registerSendCommand } from "./commands/send.js";
import { registerStatusCommand } from "./commands/status.js";
import { getLogger } from "./logging.js";

// Initialize logger
getLogger();

// Create CLI program
const program = createProgram();

// Register commands
registerSendCommand(program);
registerRelayCommand(program);
registerStatusCommand(program);

// Parse and execute
program.parse();

```

File: src/logger.ts (209 tokens)
```
import { danger, info, isVerbose, logVerbose, success, warn } from "./globals.js";
import { getLogger } from "./logging.js";
import { type RuntimeEnv, defaultRuntime } from "./runtime.js";

export function logInfo(message: string, runtime: RuntimeEnv = defaultRuntime) {
	runtime.log(info(message));
	getLogger().info(message);
}

export function logWarn(message: string, runtime: RuntimeEnv = defaultRuntime) {
	runtime.log(warn(message));
	getLogger().warn(message);
}

export function logSuccess(message: string, runtime: RuntimeEnv = defaultRuntime) {
	runtime.log(success(message));
	getLogger().info(message);
}

export function logError(message: string, runtime: RuntimeEnv = defaultRuntime) {
	runtime.error(danger(message));
	getLogger().error(message);
}

export function logDebug(message: string) {
	// Always emit to file logger (level-filtered); console only when verbose.
	getLogger().debug(message);
	if (isVerbose()) logVerbose(message);
}

```

File: src/logging.ts (637 tokens)
```
import fs from "node:fs";
import os from "node:os";
import path from "node:path";

import pino, { type Bindings, type LevelWithSilent, type Logger } from "pino";
import { type TelclaudeConfig, loadConfig } from "./config/config.js";
import { isVerbose } from "./globals.js";

const DEFAULT_LOG_DIR = path.join(os.tmpdir(), "telclaude");
export const DEFAULT_LOG_FILE = path.join(DEFAULT_LOG_DIR, "telclaude.log");

const ALLOWED_LEVELS: readonly LevelWithSilent[] = [
	"silent",
	"fatal",
	"error",
	"warn",
	"info",
	"debug",
	"trace",
];

export type LoggerSettings = {
	level?: LevelWithSilent;
	file?: string;
};

type ResolvedSettings = {
	level: LevelWithSilent;
	file: string;
};
export type LoggerResolvedSettings = ResolvedSettings;

let cachedLogger: Logger | null = null;
let cachedSettings: ResolvedSettings | null = null;
let overrideSettings: LoggerSettings | null = null;

function normalizeLevel(level?: string): LevelWithSilent {
	if (isVerbose()) return "debug";
	const candidate = level ?? "info";
	return ALLOWED_LEVELS.includes(candidate as LevelWithSilent)
		? (candidate as LevelWithSilent)
		: "info";
}

function resolveSettings(): ResolvedSettings {
	const cfg: TelclaudeConfig["logging"] | undefined = overrideSettings ?? loadConfig().logging;
	const level = normalizeLevel(cfg?.level);
	const file = cfg?.file ?? DEFAULT_LOG_FILE;
	return { level, file };
}

function settingsChanged(a: ResolvedSettings | null, b: ResolvedSettings) {
	if (!a) return true;
	return a.level !== b.level || a.file !== b.file;
}

function buildLogger(settings: ResolvedSettings): Logger {
	fs.mkdirSync(path.dirname(settings.file), { recursive: true });
	const destination = pino.destination({
		dest: settings.file,
		mkdir: true,
		sync: true, // deterministic for tests; log volume is modest.
	});
	return pino(
		{
			level: settings.level,
			base: undefined,
			timestamp: pino.stdTimeFunctions.isoTime,
		},
		destination,
	);
}

export function getLogger(): Logger {
	const settings = resolveSettings();
	if (!cachedLogger || settingsChanged(cachedSettings, settings)) {
		cachedLogger = buildLogger(settings);
		cachedSettings = settings;
	}
	return cachedLogger;
}

export function getChildLogger(bindings?: Bindings, opts?: { level?: LevelWithSilent }): Logger {
	return getLogger().child(bindings ?? {}, opts);
}

export function getResolvedLoggerSettings(): LoggerResolvedSettings {
	return resolveSettings();
}

// Test helpers
export function setLoggerOverride(settings: LoggerSettings | null) {
	overrideSettings = settings;
	cachedLogger = null;
	cachedSettings = null;
}

export function resetLogger() {
	cachedLogger = null;
	cachedSettings = null;
	overrideSettings = null;
}

```

File: src/media/index.ts (19 tokens)
```
// Media handling exports

export * from "./parse.js";
export * from "./store.js";

```

File: src/media/parse.ts (692 tokens)
```
// Shared helpers for parsing MEDIA tokens from command/stdout text.

// Allow optional wrapping backticks and punctuation after the token; capture the core token.
export const MEDIA_TOKEN_RE = /\bMEDIA:\s*`?([^\n]+)`?/gi;

export function normalizeMediaSource(src: string) {
	return src.startsWith("file://") ? src.replace("file://", "") : src;
}

function cleanCandidate(raw: string) {
	return raw.replace(/^[`"'[{(]+/, "").replace(/[`"'\\})\],]+$/, "");
}

function isValidMedia(candidate: string) {
	if (!candidate) return false;
	if (candidate.length > 1024) return false;
	if (/\s/.test(candidate)) return false;
	return /^https?:\/\//i.test(candidate) || candidate.startsWith("/") || candidate.startsWith("./");
}

export function splitMediaFromOutput(raw: string): {
	text: string;
	mediaUrls?: string[];
	mediaUrl?: string; // legacy first item for backward compatibility
} {
	const trimmedRaw = raw.trim();
	if (!trimmedRaw) return { text: "" };

	const media: string[] = [];
	let foundMediaToken = false;

	// Collect tokens line by line so we can strip them cleanly.
	const lines = trimmedRaw.split("\n");
	const keptLines: string[] = [];

	for (const line of lines) {
		const matches = Array.from(line.matchAll(MEDIA_TOKEN_RE));
		if (matches.length === 0) {
			keptLines.push(line);
			continue;
		}

		foundMediaToken = true;
		const pieces: string[] = [];
		let cursor = 0;
		let hasValidMedia = false;

		for (const match of matches) {
			const start = match.index ?? 0;
			pieces.push(line.slice(cursor, start));

			const payload = match[1];
			const parts = payload.split(/\s+/).filter(Boolean);
			const invalidParts: string[] = [];
			for (const part of parts) {
				const candidate = normalizeMediaSource(cleanCandidate(part));
				if (isValidMedia(candidate)) {
					media.push(candidate);
					hasValidMedia = true;
				} else {
					invalidParts.push(part);
				}
			}

			if (hasValidMedia && invalidParts.length > 0) {
				pieces.push(invalidParts.join(" "));
			}

			cursor = start + match[0].length;
		}

		pieces.push(line.slice(cursor));

		const cleanedLine = pieces
			.join("")
			.replace(/[ \t]{2,}/g, " ")
			.trim();

		// If the line becomes empty, drop it.
		if (cleanedLine) {
			keptLines.push(cleanedLine);
		}
	}

	const cleanedText = keptLines
		.join("\n")
		.replace(/[ \t]+\n/g, "\n")
		.replace(/[ \t]{2,}/g, " ")
		.replace(/\n{2,}/g, "\n")
		.trim();

	if (media.length === 0) {
		return { text: foundMediaToken ? cleanedText : trimmedRaw };
	}

	return { text: cleanedText, mediaUrls: media, mediaUrl: media[0] };
}

```

File: src/media/store.ts (531 tokens)
```
import crypto from "node:crypto";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";

const MEDIA_DIR = path.join(os.tmpdir(), "telclaude", "media");

export type SavedMedia = {
	path: string;
	contentType: string;
};

/**
 * Save a buffer to a temporary file and return its path.
 */
export async function saveMediaBuffer(buffer: Buffer, mimeType?: string): Promise<SavedMedia> {
	await fs.promises.mkdir(MEDIA_DIR, { recursive: true });

	const ext = mimeToExtension(mimeType);
	const hash = crypto.createHash("sha256").update(buffer).digest("hex").slice(0, 16);
	const filename = `${Date.now()}-${hash}${ext}`;
	const filepath = path.join(MEDIA_DIR, filename);

	await fs.promises.writeFile(filepath, buffer);

	return {
		path: filepath,
		contentType: mimeType ?? "application/octet-stream",
	};
}

/**
 * Get file extension from MIME type.
 */
function mimeToExtension(mime?: string): string {
	if (!mime) return "";
	const mapping: Record<string, string> = {
		"image/jpeg": ".jpg",
		"image/png": ".png",
		"image/gif": ".gif",
		"image/webp": ".webp",
		"audio/ogg": ".ogg",
		"audio/mpeg": ".mp3",
		"audio/mp4": ".m4a",
		"video/mp4": ".mp4",
		"video/webm": ".webm",
		"application/pdf": ".pdf",
		"text/plain": ".txt",
	};
	return mapping[mime] ?? "";
}

/**
 * Clean up old media files.
 */
export async function cleanupOldMedia(maxAgeMs: number = 24 * 60 * 60 * 1000): Promise<number> {
	try {
		const files = await fs.promises.readdir(MEDIA_DIR);
		const now = Date.now();
		let cleaned = 0;

		for (const file of files) {
			const filepath = path.join(MEDIA_DIR, file);
			try {
				const stat = await fs.promises.stat(filepath);
				if (now - stat.mtimeMs > maxAgeMs) {
					await fs.promises.unlink(filepath);
					cleaned++;
				}
			} catch {
				// Ignore individual file errors
			}
		}

		return cleaned;
	} catch {
		return 0;
	}
}

```

File: src/process/command-queue.ts (385 tokens)
```
// Minimal in-process queue to serialize command executions.
// Ensures only one command runs at a time across webhook, poller, and telegram flows.

type QueueEntry = {
	task: () => Promise<unknown>;
	resolve: (value: unknown) => void;
	reject: (reason?: unknown) => void;
	enqueuedAt: number;
	warnAfterMs: number;
	onWait?: (waitMs: number, queuedAhead: number) => void;
};

const queue: QueueEntry[] = [];
let draining = false;

async function drainQueue() {
	if (draining) return;
	draining = true;
	while (queue.length) {
		const entry = queue.shift() as QueueEntry;
		const waitedMs = Date.now() - entry.enqueuedAt;
		if (waitedMs >= entry.warnAfterMs) {
			entry.onWait?.(waitedMs, queue.length);
		}
		try {
			const result = await entry.task();
			entry.resolve(result);
		} catch (err) {
			entry.reject(err);
		}
	}
	draining = false;
}

export function enqueueCommand<T>(
	task: () => Promise<T>,
	opts?: {
		warnAfterMs?: number;
		onWait?: (waitMs: number, queuedAhead: number) => void;
	},
): Promise<T> {
	const warnAfterMs = opts?.warnAfterMs ?? 2_000;
	return new Promise<T>((resolve, reject) => {
		queue.push({
			task: () => task(),
			resolve: (value) => resolve(value as T),
			reject,
			enqueuedAt: Date.now(),
			warnAfterMs,
			onWait: opts?.onWait,
		});
		void drainQueue();
	});
}

export function getQueueSize() {
	return queue.length + (draining ? 1 : 0);
}

```

File: src/process/exec.ts (654 tokens)
```
import { execFile, spawn } from "node:child_process";
import { promisify } from "node:util";

import { danger, isVerbose } from "../globals.js";
import { logDebug, logError } from "../logger.js";

const execFileAsync = promisify(execFile);

// Simple promise-wrapped execFile with optional verbosity logging.
export async function runExec(
	command: string,
	args: string[],
	opts: number | { timeoutMs?: number; maxBuffer?: number } = 10_000,
): Promise<{ stdout: string; stderr: string }> {
	const options =
		typeof opts === "number"
			? { timeout: opts, encoding: "utf8" as const }
			: {
					timeout: opts.timeoutMs,
					maxBuffer: opts.maxBuffer,
					encoding: "utf8" as const,
				};
	try {
		const { stdout, stderr } = await execFileAsync(command, args, options);
		if (isVerbose()) {
			if (stdout.trim()) logDebug(stdout.trim());
			if (stderr.trim()) logError(stderr.trim());
		}
		return { stdout, stderr };
	} catch (err) {
		if (isVerbose()) {
			logError(danger(`Command failed: ${command} ${args.join(" ")}`));
		}
		throw err;
	}
}

export type SpawnResult = {
	stdout: string;
	stderr: string;
	code: number | null;
	signal: NodeJS.Signals | null;
	killed: boolean;
};

export type CommandOptions = {
	timeoutMs: number;
	cwd?: string;
};

export async function runCommandWithTimeout(
	argv: string[],
	optionsOrTimeout: number | CommandOptions,
): Promise<SpawnResult> {
	const options: CommandOptions =
		typeof optionsOrTimeout === "number" ? { timeoutMs: optionsOrTimeout } : optionsOrTimeout;
	const { timeoutMs, cwd } = options;

	// Spawn with inherited stdin (TTY) so tools like `claude` don't hang.
	return await new Promise((resolve, reject) => {
		const child = spawn(argv[0], argv.slice(1), {
			stdio: ["inherit", "pipe", "pipe"],
			cwd,
		});
		let stdout = "";
		let stderr = "";
		let settled = false;
		const timer = setTimeout(() => {
			child.kill("SIGKILL");
		}, timeoutMs);

		child.stdout?.on("data", (d) => {
			stdout += d.toString();
		});
		child.stderr?.on("data", (d) => {
			stderr += d.toString();
		});
		child.on("error", (err) => {
			if (settled) return;
			settled = true;
			clearTimeout(timer);
			reject(err);
		});
		child.on("close", (code, signal) => {
			if (settled) return;
			settled = true;
			clearTimeout(timer);
			resolve({ stdout, stderr, code, signal, killed: child.killed });
		});
	});
}

```

File: src/process/index.ts (21 tokens)
```
// Process execution exports

export * from "./exec.js";
export * from "./command-queue.js";

```

File: src/runtime.ts (77 tokens)
```
export type RuntimeEnv = {
	log: typeof console.log;
	error: typeof console.error;
	exit: (code: number) => never;
};

export const defaultRuntime: RuntimeEnv = {
	log: console.log,
	error: console.error,
	exit: (code) => {
		process.exit(code);
		throw new Error("unreachable"); // satisfies tests when mocked
	},
};

```

File: src/security/audit.ts (916 tokens)
```
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { getChildLogger } from "../logging.js";
import type { AuditEntry } from "./types.js";

const DEFAULT_AUDIT_DIR = path.join(os.tmpdir(), "telclaude");
const DEFAULT_AUDIT_FILE = path.join(DEFAULT_AUDIT_DIR, "audit.log");

const logger = getChildLogger({ module: "audit" });

export type AuditConfig = {
	enabled: boolean;
	logFile?: string;
};

/**
 * Audit logger for security events.
 */
export class AuditLogger {
	private config: AuditConfig;
	private logFile: string;

	constructor(config: AuditConfig) {
		this.config = config;
		this.logFile = config.logFile ?? DEFAULT_AUDIT_FILE;

		if (config.enabled) {
			// Ensure directory exists
			const dir = path.dirname(this.logFile);
			if (!fs.existsSync(dir)) {
				fs.mkdirSync(dir, { recursive: true });
			}
		}
	}

	/**
	 * Log an audit entry.
	 */
	async log(entry: AuditEntry): Promise<void> {
		if (!this.config.enabled) return;

		try {
			const line = JSON.stringify({
				...entry,
				timestamp: entry.timestamp.toISOString(),
			});

			await fs.promises.appendFile(this.logFile, `${line}\n`, "utf-8");

			// Also log to the regular logger
			logger.info(
				{
					requestId: entry.requestId,
					userId: entry.telegramUserId,
					outcome: entry.outcome,
					classification: entry.observerClassification,
				},
				"audit entry logged",
			);
		} catch (err) {
			logger.error({ error: String(err) }, "failed to write audit log");
		}
	}

	/**
	 * Log a blocked request.
	 */
	async logBlocked(entry: Omit<AuditEntry, "outcome">, reason: string): Promise<void> {
		await this.log({
			...entry,
			outcome: "blocked",
			errorType: reason,
		});
	}

	/**
	 * Log a rate-limited request.
	 */
	async logRateLimited(telegramUserId: string, chatId: number, tier: string): Promise<void> {
		await this.log({
			timestamp: new Date(),
			requestId: `rate_${Date.now()}`,
			telegramUserId,
			chatId,
			messagePreview: "(rate limited)",
			permissionTier: tier as AuditEntry["permissionTier"],
			outcome: "rate_limited",
		});
	}

	/**
	 * Read recent audit entries.
	 */
	async readRecent(limit = 100): Promise<AuditEntry[]> {
		if (!this.config.enabled) return [];

		try {
			const content = await fs.promises.readFile(this.logFile, "utf-8");
			const lines = content.trim().split("\n").filter(Boolean);
			const entries = lines
				.slice(-limit)
				.map((line) => {
					try {
						const parsed = JSON.parse(line);
						return {
							...parsed,
							timestamp: new Date(parsed.timestamp),
						} as AuditEntry;
					} catch {
						return null;
					}
				})
				.filter((e): e is AuditEntry => e !== null);

			return entries;
		} catch {
			return [];
		}
	}

	/**
	 * Get statistics from audit log.
	 */
	async getStats(): Promise<{
		total: number;
		blocked: number;
		rateLimited: number;
		errors: number;
		success: number;
	}> {
		const entries = await this.readRecent(1000);
		return {
			total: entries.length,
			blocked: entries.filter((e) => e.outcome === "blocked").length,
			rateLimited: entries.filter((e) => e.outcome === "rate_limited").length,
			errors: entries.filter((e) => e.outcome === "error").length,
			success: entries.filter((e) => e.outcome === "success").length,
		};
	}
}

/**
 * Create an audit logger from config.
 */
export function createAuditLogger(config: AuditConfig): AuditLogger {
	return new AuditLogger(config);
}

```

File: src/security/fast-path.ts (1116 tokens)
```
import type { SecurityClassification } from "./types.js";

/**
 * Patterns that are clearly safe and can skip LLM review.
 */
export const SAFE_PATTERNS: RegExp[] = [
	// Information requests
	/^(what|how|why|explain|describe|help|show me|tell me)/i,
	/^(list|read|cat|head|tail|less|more)\s/i,
	/^(search|find|grep|look for)/i,

	// Git read operations
	/^git\s+(status|log|diff|branch|remote\s+-v|show)/i,

	// Safe file operations
	/^ls\s+-?[lahR]*\s*/i,
	/^pwd$/i,
	/^echo\s+[^;|&$`]+$/i, // Simple echo without injection
	/^whoami$/i,
	/^date$/i,
	/^uptime$/i,

	// Questions
	/\?$/,
];

/**
 * Patterns that are clearly dangerous and should be blocked immediately.
 */
export const DANGEROUS_PATTERNS: RegExp[] = [
	// Destructive file operations
	/rm\s+-rf?\s*\//i,
	/rm\s+-rf?\s*~\//i,
	/>\s*\/etc\//i,
	/chmod\s+777/i,
	/chown\s+.*\s+\//i,

	// Shell injection attempts
	/curl.*\|\s*(ba)?sh/i,
	/wget.*\|\s*(ba)?sh/i,
	/\$\([^)]+\)/i, // Command substitution
	/`[^`]+`/, // Backtick execution
	/;\s*(rm|chmod|chown|sudo|su\s)/i, // Command chaining to dangerous

	// Dangerous flags
	/--dangerously/i,
	/--force/i,
	/--no-preserve-root/i,

	// Privilege escalation
	/sudo\s+/i,
	/su\s+-?\s*$/i,
	/pkexec/i,

	// Prompt injection attempts
	/ignore\s+(all\s+)?previous\s+instructions?/i,
	/disregard\s+(all\s+)?prior\s+instructions?/i,
	/forget\s+(all\s+)?your\s+instructions?/i,
	/you\s+are\s+now\s+/i,
	/your\s+new\s+(role|persona|identity)/i,
	/system\s*prompt/i,
	/reveal\s+your\s+prompt/i,

	// Network exfiltration
	/curl\s+.*-X\s*(POST|PUT)/i,
	/nc\s+-e/i,
	/netcat.*-e/i,

	// Process manipulation
	/kill\s+-9\s+1$/i,
	/killall/i,
	/pkill\s+/i,
];

/**
 * Fast-path classification without LLM.
 * Returns null if LLM review is needed.
 */
export function fastPathClassify(message: string): {
	classification: SecurityClassification;
	reason: string;
} | null {
	const trimmed = message.trim();

	// Check dangerous patterns first
	for (const pattern of DANGEROUS_PATTERNS) {
		if (pattern.test(trimmed)) {
			return {
				classification: "BLOCK",
				reason: `Matched dangerous pattern: ${pattern.source}`,
			};
		}
	}

	// Check safe patterns
	for (const pattern of SAFE_PATTERNS) {
		if (pattern.test(trimmed)) {
			return {
				classification: "ALLOW",
				reason: `Matched safe pattern: ${pattern.source}`,
			};
		}
	}

	// Need LLM review
	return null;
}

/**
 * Check for structural issues that might indicate an attack.
 */
export function checkStructuralIssues(message: string): string[] {
	const issues: string[] = [];

	// Check for zero-width characters (hidden text)
	// Using alternation instead of character class due to ZWJ combining behavior
	if (/\u200B|\u200C|\u200D|\uFEFF/.test(message)) {
		issues.push("Contains zero-width characters");
	}

	// Check for excessive repetition (trying to overwhelm context)
	const words = message.toLowerCase().split(/\s+/);
	const wordCounts = new Map<string, number>();
	for (const word of words) {
		wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
	}
	const maxCount = Math.max(...wordCounts.values());
	if (maxCount > 50 || (words.length > 10 && maxCount / words.length > 0.3)) {
		issues.push("Excessive word repetition detected");
	}

	// Check for mixed scripts (homoglyph attacks)
	const hasLatin = /[a-zA-Z]/.test(message);
	const hasCyrillic = /[\u0400-\u04FF]/.test(message);
	if (hasLatin && hasCyrillic) {
		issues.push("Mixed Latin and Cyrillic scripts (possible homoglyph attack)");
	}

	// Check for unusually long message
	if (message.length > 10000) {
		issues.push("Unusually long message");
	}

	return issues;
}

```

File: src/security/index.ts (49 tokens)
```
// Security layer exports

export * from "./types.js";
export * from "./fast-path.js";
export * from "./observer.js";
export * from "./permissions.js";
export * from "./rate-limit.js";
export * from "./audit.js";

```

File: src/security/observer.ts (excerpt)
```
import { execFileSync } from "node:child_process";
import type { PermissionTier } from "../config/config.js";
import { getChildLogger } from "../logging.js";
import { checkStructuralIssues, fastPathClassify } from "./fast-path.js";
import type { ObserverResult, SecurityClassification } from "./types.js";
import { runCommandWithTimeout } from "../process/exec.js";
import { parseClaudeJsonText, CLAUDE_BIN } from "../auto-reply/claude.js";

export type ObserverConfig = {
    enabled: boolean;
    maxLatencyMs: number;
    dangerThreshold: number;
    fallbackOnTimeout: "allow" | "block" | "escalate";
    claudeBin?: string;
    model?: string;
    maxTokens?: number;
};

// analyze(): fast-path → Claude CLI (json output) → threshold downgrades; 
// degrades to fallback when CLI missing or errors.
```


File: src/security/permissions.ts (588 tokens)
```
import type { PermissionTier, SecurityConfig } from "../config/config.js";
import { chatIdToString } from "../utils.js";

/**
 * Capabilities for each permission tier.
 */
export const TIER_CAPABILITIES: Record<
	PermissionTier,
	{
		claudeFlags: string[];
		description: string;
	}
> = {
	READ_ONLY: {
		claudeFlags: ["--allowedTools", "Read,Glob,Grep,WebFetch,WebSearch"],
		description: "Can only read files and search. No write operations allowed.",
	},
	WRITE_SAFE: {
		claudeFlags: [
			"--allowedTools",
			"Read,Glob,Grep,Write,Edit,WebFetch,WebSearch",
			"--disallowedCommands",
			"rm,rmdir,mv,chmod,chown,kill,pkill",
		],
		description: "Can read and write files, but cannot delete or modify permissions.",
	},
	FULL_ACCESS: {
		claudeFlags: ["--dangerously-skip-permissions"],
		description: "Full system access with no restrictions.",
	},
};

/**
 * Get the permission tier for a user.
 */
export function getUserPermissionTier(
	userId: string | number,
	securityConfig?: SecurityConfig,
): PermissionTier {
	const normalizedId = typeof userId === "number" ? String(userId) : userId;
	const withPrefix = chatIdToString(userId);

	// Check user-specific permissions
	const userPerms = securityConfig?.permissions?.users;
	if (userPerms) {
		// Try both with and without prefix
		if (userPerms[normalizedId]) {
			return userPerms[normalizedId].tier;
		}
		if (userPerms[withPrefix]) {
			return userPerms[withPrefix].tier;
		}
	}

	// Return default tier
	return securityConfig?.permissions?.defaultTier ?? "READ_ONLY";
}

/**
 * Get Claude CLI flags for a permission tier.
 */
export function getClaudeFlagsForTier(tier: PermissionTier): string[] {
	return TIER_CAPABILITIES[tier].claudeFlags;
}

/**
 * Check if a user has at least the specified permission tier.
 */
export function hasMinimumTier(userTier: PermissionTier, requiredTier: PermissionTier): boolean {
	const tierOrder: PermissionTier[] = ["READ_ONLY", "WRITE_SAFE", "FULL_ACCESS"];
	return tierOrder.indexOf(userTier) >= tierOrder.indexOf(requiredTier);
}

/**
 * Format tier for display.
 */
export function formatTier(tier: PermissionTier): string {
	switch (tier) {
		case "READ_ONLY":
			return "Read Only";
		case "WRITE_SAFE":
			return "Write Safe";
		case "FULL_ACCESS":
			return "Full Access";
	}
}

```

File: src/security/rate-limit.ts (1540 tokens)
```
import { RateLimiterMemory } from "rate-limiter-flexible";
import type { PermissionTier, SecurityConfig } from "../config/config.js";
import { getChildLogger } from "../logging.js";
import type { RateLimitResult } from "./types.js";

const logger = getChildLogger({ module: "rate-limit" });

/**
 * Rate limiter configuration.
 */
export type RateLimitConfig = {
	global: {
		perMinute: number;
		perHour: number;
	};
	perUser: {
		perMinute: number;
		perHour: number;
	};
	perTier: Record<PermissionTier, { perMinute: number; perHour: number }>;
};

const DEFAULT_RATE_LIMITS: RateLimitConfig = {
	global: {
		perMinute: 100,
		perHour: 1000,
	},
	perUser: {
		perMinute: 10,
		perHour: 60,
	},
	perTier: {
		READ_ONLY: { perMinute: 20, perHour: 200 },
		WRITE_SAFE: { perMinute: 10, perHour: 100 },
		FULL_ACCESS: { perMinute: 5, perHour: 30 },
	},
};

/**
 * Rate limiter manager with per-tier enforcement.
 */
export class RateLimiter {
	private globalMinute: RateLimiterMemory;
	private globalHour: RateLimiterMemory;
	private tierMinuteLimiters: Map<PermissionTier, RateLimiterMemory>;
	private tierHourLimiters: Map<PermissionTier, RateLimiterMemory>;
	private config: RateLimitConfig;

	constructor(securityConfig?: SecurityConfig) {
		this.config = this.mergeConfig(securityConfig);

		this.globalMinute = new RateLimiterMemory({
			points: this.config.global.perMinute,
			duration: 60,
		});

		this.globalHour = new RateLimiterMemory({
			points: this.config.global.perHour,
			duration: 3600,
		});

		// Create per-tier limiters
		this.tierMinuteLimiters = new Map();
		this.tierHourLimiters = new Map();

		for (const tier of ["READ_ONLY", "WRITE_SAFE", "FULL_ACCESS"] as PermissionTier[]) {
			const tierLimits = this.config.perTier[tier];
			this.tierMinuteLimiters.set(
				tier,
				new RateLimiterMemory({
					points: tierLimits.perMinute,
					duration: 60,
				}),
			);
			this.tierHourLimiters.set(
				tier,
				new RateLimiterMemory({
					points: tierLimits.perHour,
					duration: 3600,
				}),
			);
		}
	}

	private mergeConfig(securityConfig?: SecurityConfig): RateLimitConfig {
		const rateLimits = securityConfig?.rateLimits;
		return {
			global: {
				perMinute: rateLimits?.global?.perMinute ?? DEFAULT_RATE_LIMITS.global.perMinute,
				perHour: rateLimits?.global?.perHour ?? DEFAULT_RATE_LIMITS.global.perHour,
			},
			perUser: {
				perMinute: rateLimits?.perUser?.perMinute ?? DEFAULT_RATE_LIMITS.perUser.perMinute,
				perHour: rateLimits?.perUser?.perHour ?? DEFAULT_RATE_LIMITS.perUser.perHour,
			},
			perTier: {
				READ_ONLY: rateLimits?.perTier?.READ_ONLY ?? DEFAULT_RATE_LIMITS.perTier.READ_ONLY,
				WRITE_SAFE: rateLimits?.perTier?.WRITE_SAFE ?? DEFAULT_RATE_LIMITS.perTier.WRITE_SAFE,
				FULL_ACCESS: rateLimits?.perTier?.FULL_ACCESS ?? DEFAULT_RATE_LIMITS.perTier.FULL_ACCESS,
			},
		};
	}

	/**
	 * Check if a request is allowed, enforcing per-tier limits.
	 */
	async checkLimit(userId: string, tier: PermissionTier): Promise<RateLimitResult> {
		try {
			// Check global limits first
			try {
				await this.globalMinute.consume("global", 1);
			} catch {
				logger.warn("global minute rate limit hit");
				return {
					allowed: false,
					remaining: 0,
					resetMs: 60000,
					limitType: "global",
				};
			}

			try {
				await this.globalHour.consume("global", 1);
			} catch {
				logger.warn("global hour rate limit hit");
				return {
					allowed: false,
					remaining: 0,
					resetMs: 3600000,
					limitType: "global",
				};
			}

			// Check tier-specific user limits
			const tierMinuteLimiter = this.tierMinuteLimiters.get(tier);
			const tierHourLimiter = this.tierHourLimiters.get(tier);

			if (!tierMinuteLimiter || !tierHourLimiter) {
				logger.error({ tier }, "missing tier limiter");
				return { allowed: true, remaining: 0, resetMs: 0 };
			}

			const tierLimits = this.config.perTier[tier];

			try {
				const minuteResult = await tierMinuteLimiter.consume(userId, 1);
				const remaining = Math.max(0, tierLimits.perMinute - minuteResult.consumedPoints);

				// Also check hour limit
				await tierHourLimiter.consume(userId, 1);

				return {
					allowed: true,
					remaining,
					resetMs: minuteResult.msBeforeNext,
					limitType: "user",
				};
			} catch (err) {
				const rateLimitErr = err as { msBeforeNext?: number };
				logger.info({ userId, tier }, "user rate limit hit for tier");
				return {
					allowed: false,
					remaining: 0,
					resetMs: rateLimitErr.msBeforeNext ?? 60000,
					limitType: "user",
				};
			}
		} catch (err) {
			logger.error({ error: String(err) }, "rate limit check error");
			// On error, allow the request but log it
			return {
				allowed: true,
				remaining: 0,
				resetMs: 0,
			};
		}
	}

	/**
	 * Reset rate limits for a user across all tiers.
	 */
	async resetUser(userId: string): Promise<void> {
		for (const limiter of this.tierMinuteLimiters.values()) {
			await limiter.delete(userId);
		}
		for (const limiter of this.tierHourLimiters.values()) {
			await limiter.delete(userId);
		}
	}

	/**
	 * Get current usage for a user in a specific tier.
	 */
	async getUserUsage(
		userId: string,
		tier: PermissionTier,
	): Promise<{ minute: number; hour: number }> {
		const minuteLimiter = this.tierMinuteLimiters.get(tier);
		const hourLimiter = this.tierHourLimiters.get(tier);

		const minuteRes = await minuteLimiter?.get(userId);
		const hourRes = await hourLimiter?.get(userId);

		return {
			minute: minuteRes?.consumedPoints ?? 0,
			hour: hourRes?.consumedPoints ?? 0,
		};
	}
}

/**
 * Create a rate limiter from config.
 */
export function createRateLimiter(securityConfig?: SecurityConfig): RateLimiter {
	return new RateLimiter(securityConfig);
}

```

File: src/security/types.ts (241 tokens)
```
import type { PermissionTier } from "../config/config.js";

/**
 * Classification result from the security observer.
 */
export type SecurityClassification = "ALLOW" | "WARN" | "BLOCK";

/**
 * Result from analyzing a message.
 */
export type ObserverResult = {
	classification: SecurityClassification;
	confidence: number;
	reason?: string;
	flaggedPatterns?: string[];
	suggestedTier?: PermissionTier;
	latencyMs: number;
};

/**
 * Audit log entry.
 */
export type AuditEntry = {
	timestamp: Date;
	requestId: string;
	telegramUserId: string;
	telegramUsername?: string;
	chatId: number;
	messagePreview: string;
	observerClassification?: SecurityClassification;
	observerConfidence?: number;
	permissionTier: PermissionTier;
	executionTimeMs?: number;
	outcome: "success" | "blocked" | "timeout" | "error" | "rate_limited";
	errorType?: string;
};

/**
 * Rate limit check result.
 */
export type RateLimitResult = {
	allowed: boolean;
	remaining: number;
	resetMs: number;
	limitType?: "global" | "user" | "tier";
};

```

File: src/telegram/auto-reply.ts (3144 tokens)
```
import crypto from "node:crypto";
import { run } from "@grammyjs/runner";
import type { Bot } from "grammy";

import { runCommandReply } from "../auto-reply/command-reply.js";
import type { TemplateContext } from "../auto-reply/templating.js";
import { type TelclaudeConfig, loadConfig } from "../config/config.js";
import {
	DEFAULT_IDLE_MINUTES,
	type SessionEntry,
	deriveSessionKey,
	loadSessionStore,
	resolveStorePath,
	saveSessionStore,
} from "../config/sessions.js";
import { getChildLogger } from "../logging.js";
import { runCommandWithTimeout } from "../process/exec.js";
import type { RuntimeEnv } from "../runtime.js";
import { type AuditLogger, createAuditLogger } from "../security/audit.js";
import { type SecurityObserver, createObserver } from "../security/observer.js";
import { getClaudeFlagsForTier, getUserPermissionTier } from "../security/permissions.js";
import { type RateLimiter, createRateLimiter } from "../security/rate-limit.js";

import { createTelegramBot } from "./client.js";
import { monitorTelegramInbox } from "./inbound.js";
import { computeBackoff, resolveReconnectPolicy, sleepWithAbort } from "./reconnect.js";
import type { TelegramInboundMessage } from "./types.js";

const logger = getChildLogger({ module: "telegram-auto-reply" });

export type MonitorOptions = {
	verbose: boolean;
	keepAlive?: boolean;
	abortSignal?: AbortSignal;
};

/**
 * Main monitoring loop for Telegram with auto-reply.
 */
export async function monitorTelegramProvider(
	options: MonitorOptions,
	_runtime?: RuntimeEnv,
): Promise<void> {
	const { verbose, keepAlive = true, abortSignal } = options;
	const cfg = loadConfig();
	const reconnectPolicy = resolveReconnectPolicy(cfg);

	// Initialize security components
	const observer = createObserver({
		enabled: cfg.security?.observer?.enabled ?? true,
		maxLatencyMs: cfg.security?.observer?.maxLatencyMs ?? 2000,
		dangerThreshold: cfg.security?.observer?.dangerThreshold ?? 0.7,
		fallbackOnTimeout: cfg.security?.observer?.fallbackOnTimeout ?? "block",
		claudeBin: cfg.security?.observer?.claudeBin ?? undefined,
		model: cfg.security?.observer?.model ?? undefined,
		maxTokens: cfg.security?.observer?.maxTokens ?? undefined,
	});

	const rateLimiter = createRateLimiter(cfg.security);
	const auditLogger = createAuditLogger({
		enabled: cfg.security?.audit?.enabled ?? true,
		logFile: cfg.security?.audit?.logFile,
	});

	// Track recently sent messages for echo detection
	const recentlySent = new Set<string>();

	let reconnectAttempts = 0;

	while (true) {
		if (abortSignal?.aborted) break;

		try {
			const token = process.env.TELEGRAM_BOT_TOKEN;
			if (!token) throw new Error("TELEGRAM_BOT_TOKEN not set");

			const { bot, botInfo } = await createTelegramBot({ token, verbose });

			logger.info({ botId: botInfo.id, username: botInfo.username }, "connected to Telegram");

			const { close, onClose } = await monitorTelegramInbox({
				bot,
				botInfo,
				verbose,
				allowedChats: cfg.telegram?.allowedChats,
				onMessage: async (msg) => {
					await handleInboundMessage(
						msg,
						bot,
						cfg,
						observer,
						rateLimiter,
						auditLogger,
						recentlySent,
					);
				},
			});

			// Start the bot
			const runner = run(bot);

			console.log("Listening for Telegram messages. Ctrl+C to stop.");

			// Reset reconnect attempts on successful connection
			reconnectAttempts = 0;

			// Wait for close or abort
			const closeReason = await Promise.race([
				onClose,
				abortSignal
					? new Promise<"aborted">((resolve) =>
							abortSignal.addEventListener("abort", () => resolve("aborted")),
						)
					: new Promise<never>(() => {}),
			]);

			// Stop the bot
			runner.stop();
			await close();

			if (closeReason === "aborted" || abortSignal?.aborted) {
				logger.info("monitor aborted by signal");
				break;
			}

			// Handle reconnection
			if (!keepAlive) break;

			reconnectAttempts++;
			if (reconnectPolicy.maxAttempts > 0 && reconnectAttempts >= reconnectPolicy.maxAttempts) {
				throw new Error(`Max reconnect attempts (${reconnectPolicy.maxAttempts}) reached`);
			}

			const delay = computeBackoff(reconnectPolicy, reconnectAttempts);
			console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts})...`);
			await sleepWithAbort(delay, abortSignal);
		} catch (err) {
			logger.error({ error: String(err) }, "monitor error");

			if (!keepAlive) throw err;

			reconnectAttempts++;
			if (reconnectPolicy.maxAttempts > 0 && reconnectAttempts >= reconnectPolicy.maxAttempts) {
				throw new Error(
					`Max reconnect attempts (${reconnectPolicy.maxAttempts}) reached: ${String(err)}`,
				);
			}

			const delay = computeBackoff(reconnectPolicy, reconnectAttempts);
			console.error(`Error: ${err}. Reconnecting in ${delay}ms...`);
			await sleepWithAbort(delay, abortSignal);
		}
	}
}

/**
 * Handle an inbound message with security checks and auto-reply.
 */
async function handleInboundMessage(
	msg: TelegramInboundMessage,
	_bot: Bot,
	cfg: TelclaudeConfig,
	observer: SecurityObserver,
	rateLimiter: RateLimiter,
	auditLogger: AuditLogger,
	recentlySent: Set<string>,
): Promise<void> {
	const requestId = `req_${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
	const userId = String(msg.chatId);
	const startTime = Date.now();

	// Echo detection - skip if we sent this message
	if (recentlySent.has(msg.body)) {
		recentlySent.delete(msg.body);
		logger.debug({ msgId: msg.id }, "echo detected, skipping");
		return;
	}

	// Get user's permission tier
	const tier = getUserPermissionTier(msg.chatId, cfg.security);

	// Check rate limits
	const rateLimitResult = await rateLimiter.checkLimit(userId, tier);
	if (!rateLimitResult.allowed) {
		logger.info({ userId, tier }, "rate limited");
		await auditLogger.logRateLimited(userId, msg.chatId, tier);
		await msg.reply(
			`Rate limit exceeded. Please wait ${Math.ceil(rateLimitResult.resetMs / 1000)} seconds.`,
		);
		return;
	}

	// Security observer check
	const observerResult = await observer.analyze(msg.body, {
		permissionTier: tier,
	});

	if (observerResult.classification === "BLOCK") {
		logger.warn({ userId, reason: observerResult.reason }, "message blocked by security observer");
		await auditLogger.logBlocked(
			{
				timestamp: new Date(),
				requestId,
				telegramUserId: userId,
				telegramUsername: msg.username,
				chatId: msg.chatId,
				messagePreview: msg.body.slice(0, 100),
				observerClassification: observerResult.classification,
				observerConfidence: observerResult.confidence,
				permissionTier: tier,
			},
			observerResult.reason ?? "Blocked by security observer",
		);
		await msg.reply(
			`This request was blocked for security reasons. ${observerResult.reason ? `Reason: ${observerResult.reason}` : ""}`,
		);
		return;
	}

	if (observerResult.classification === "WARN") {
		logger.info({ userId, reason: observerResult.reason }, "message flagged with warning");
	}

	// Get reply configuration
	const replyConfig = cfg.inbound?.reply;
	if (!replyConfig || replyConfig.mode !== "command" || !replyConfig.command?.length) {
		logger.debug("no reply config, skipping");
		return;
	}

	// Send typing indicator
	await msg.sendComposing();

	// Session handling
	const sessionConfig = replyConfig.session;
	const storePath = resolveStorePath(sessionConfig?.store);
	const store = loadSessionStore(storePath);
	const scope = sessionConfig?.scope ?? "per-sender";
	const idleMinutes = sessionConfig?.idleMinutes ?? DEFAULT_IDLE_MINUTES;
	const resetTriggers = sessionConfig?.resetTriggers ?? ["/new"];

	const sessionKey = deriveSessionKey(scope, { From: msg.from });
	const existingSession = store[sessionKey];
	const now = Date.now();

	// Check for reset triggers
	const shouldReset =
		resetTriggers.some((t) => msg.body.trim().toLowerCase().startsWith(t.toLowerCase())) ||
		(existingSession && now - existingSession.updatedAt > idleMinutes * 60 * 1000);

	let sessionEntry: SessionEntry;
	let isNewSession: boolean;
	let isFirstTurnInSession: boolean;

	if (!existingSession || shouldReset) {
		sessionEntry = {
			sessionId: crypto.randomUUID(),
			updatedAt: now,
			systemSent: false,
		};
		isNewSession = true;
		isFirstTurnInSession = true;
	} else {
		sessionEntry = existingSession;
		isNewSession = false;
		isFirstTurnInSession = false;
	}

	// Build template context
	const templatingCtx: TemplateContext = {
		Body: msg.body,
		BodyStripped: msg.body.trim(),
		From: msg.from,
		To: msg.to,
		MessageId: msg.id,
		MediaPath: msg.mediaPath,
		MediaUrl: msg.mediaUrl,
		MediaType: msg.mediaType,
		Username: msg.username,
		SessionId: sessionEntry.sessionId,
		IsNewSession: isNewSession ? "true" : "false",
	};

	// Get Claude flags for tier
	const tierFlags = getClaudeFlagsForTier(tier);

	// Modify command to include tier restrictions
	const modifiedCommand = [...(replyConfig.command ?? [])];
	if (tier !== "FULL_ACCESS" && modifiedCommand.length > 0) {
		// Insert tier flags after the command name
		modifiedCommand.splice(1, 0, ...tierFlags);
	}

	const timeoutSeconds = replyConfig.timeoutSeconds ?? 600;
	const timeoutMs = timeoutSeconds * 1000;

	// Set up typing indicator refresh
	const typingInterval = (replyConfig.typingIntervalSeconds ?? 8) * 1000;
	const typingTimer = setInterval(() => {
		msg.sendComposing().catch(() => {});
	}, typingInterval);

	try {
		const result = await runCommandReply({
			reply: { ...replyConfig, mode: "command", command: modifiedCommand },
			templatingCtx,
			sendSystemOnce: sessionConfig?.sendSystemOnce ?? false,
			isNewSession,
			isFirstTurnInSession,
			systemSent: sessionEntry.systemSent ?? false,
			timeoutMs,
			timeoutSeconds,
			commandRunner: runCommandWithTimeout,
		});

		// Check if command failed (non-zero exit or killed)
		const commandFailed =
			result.meta?.exitCode !== undefined && result.meta.exitCode !== 0 && !result.payload?.text;
		const commandKilled = result.meta?.killed && !result.payload?.text;

		if (commandFailed || commandKilled) {
			// Command failed - notify user and log as error
			const exitInfo = result.meta?.exitCode
				? `exit code ${result.meta.exitCode}`
				: result.meta?.signal
					? `signal ${result.meta.signal}`
					: "unknown error";
			logger.warn(
				{ requestId, exitCode: result.meta?.exitCode, signal: result.meta?.signal },
				"command failed",
			);
			await msg.reply(`Command failed (${exitInfo}). Please try again or rephrase your request.`);
			await auditLogger.log({
				timestamp: new Date(),
				requestId,
				telegramUserId: userId,
				telegramUsername: msg.username,
				chatId: msg.chatId,
				messagePreview: msg.body.slice(0, 100),
				observerClassification: observerResult.classification,
				observerConfidence: observerResult.confidence,
				permissionTier: tier,
				executionTimeMs: Date.now() - startTime,
				outcome: "error",
				errorType: `command_failed:${exitInfo}`,
			});
			return;
		}

		if (result.payload?.text || result.payload?.mediaUrl) {
			// Send reply
			if (result.payload.mediaUrl) {
				await msg.sendMedia({
					type: "document",
					source: result.payload.mediaUrl,
					caption: result.payload.text,
				});
			} else if (result.payload.text) {
				await msg.reply(result.payload.text);
			}

			// Track for echo detection
			if (result.payload?.text) {
				const textToTrack = result.payload.text;
				recentlySent.add(textToTrack);
				// Clean up after 30 seconds
				setTimeout(() => recentlySent.delete(textToTrack), 30000);
			}

			// Update session
			sessionEntry.updatedAt = Date.now();
			sessionEntry.systemSent = true;
			store[sessionKey] = sessionEntry;
			await saveSessionStore(storePath, store);
		}

		// Log audit entry
		await auditLogger.log({
			timestamp: new Date(),
			requestId,
			telegramUserId: userId,
			telegramUsername: msg.username,
			chatId: msg.chatId,
			messagePreview: msg.body.slice(0, 100),
			observerClassification: observerResult.classification,
			observerConfidence: observerResult.confidence,
			permissionTier: tier,
			executionTimeMs: Date.now() - startTime,
			outcome: "success",
		});
	} catch (err) {
		logger.error({ requestId, error: String(err) }, "reply failed");
		await auditLogger.log({
			timestamp: new Date(),
			requestId,
			telegramUserId: userId,
			telegramUsername: msg.username,
			chatId: msg.chatId,
			messagePreview: msg.body.slice(0, 100),
			observerClassification: observerResult.classification,
			observerConfidence: observerResult.confidence,
			permissionTier: tier,
			executionTimeMs: Date.now() - startTime,
			outcome: "error",
			errorType: String(err),
		});

		await msg.reply("An error occurred while processing your request. Please try again.");
	} finally {
		clearInterval(typingTimer);
	}
}

```

File: src/telegram/client.ts (553 tokens)
```
import { autoRetry } from "@grammyjs/auto-retry";
import { Bot, GrammyError, HttpError } from "grammy";
import { getChildLogger } from "../logging.js";
import type { BotInfo } from "./types.js";

export type TelegramBotOptions = {
	token: string;
	verbose?: boolean;
};

export type TelegramBotInstance = {
	bot: Bot;
	botInfo: BotInfo;
};

/**
 * Create and configure a Telegram bot instance.
 */
export async function createTelegramBot(options: TelegramBotOptions): Promise<TelegramBotInstance> {
	const logger = getChildLogger({ module: "telegram-client" });

	const bot = new Bot(options.token);

	// Auto-retry on rate limits (429) and network errors
	bot.api.config.use(
		autoRetry({
			maxRetryAttempts: 5,
			maxDelaySeconds: 60,
			rethrowInternalServerErrors: false,
		}),
	);

	// Error handling
	bot.catch((err) => {
		const ctx = err.ctx;
		const error = err.error;

		if (error instanceof GrammyError) {
			logger.error(
				{
					updateId: ctx.update.update_id,
					description: error.description,
					code: error.error_code,
				},
				"Grammy error",
			);
		} else if (error instanceof HttpError) {
			logger.error(
				{
					updateId: ctx.update.update_id,
					error: String(error),
				},
				"HTTP error",
			);
		} else {
			logger.error(
				{
					updateId: ctx.update.update_id,
					error: String(error),
				},
				"Unknown error",
			);
		}
	});

	// Get bot info to confirm token validity
	const me = await bot.api.getMe();
	logger.info({ botId: me.id, username: me.username }, "bot authenticated");

	return { bot, botInfo: me };
}

/**
 * Validate a bot token by attempting to get bot info.
 */
export async function validateBotToken(token: string): Promise<BotInfo | null> {
	try {
		const bot = new Bot(token);
		const me = await bot.api.getMe();
		return me;
	} catch {
		return null;
	}
}

/**
 * Format bot info for display.
 */
export function formatBotInfo(botInfo: BotInfo): string {
	const parts = [`Bot: ${botInfo.first_name}`];
	if (botInfo.username) {
		parts.push(`(@${botInfo.username})`);
	}
	parts.push(`[ID: ${botInfo.id}]`);
	return parts.join(" ");
}

```

File: src/telegram/inbound.ts (1404 tokens)
```
import type { Bot, Context } from "grammy";

import { getChildLogger } from "../logging.js";
import { saveMediaBuffer } from "../media/store.js";
import { chatIdToString } from "../utils.js";
import { sendMediaToChat } from "./outbound.js";
import {
	type BotInfo,
	type TelegramInboundMessage,
	type TelegramListenerCloseReason,
	type TelegramMediaPayload,
	buildPushName,
	getFileIdFromMessage,
	getMediaTypeFromMessage,
	getMimeTypeFromMessage,
} from "./types.js";

export type InboxMonitorOptions = {
	bot: Bot;
	botInfo: BotInfo;
	verbose: boolean;
	onMessage: (msg: TelegramInboundMessage) => Promise<void>;
	allowedChats?: (number | string)[];
};

export type InboxMonitorHandle = {
	close: () => Promise<void>;
	onClose: Promise<TelegramListenerCloseReason>;
};

/**
 * Monitor incoming Telegram messages.
 */
export async function monitorTelegramInbox(
	options: InboxMonitorOptions,
): Promise<InboxMonitorHandle> {
	const { bot, botInfo, verbose, onMessage, allowedChats } = options;
	const logger = getChildLogger({ module: "telegram-inbound" });
	const seen = new Set<string>();

	let onCloseResolve: ((reason: TelegramListenerCloseReason) => void) | null = null;
	const onClose = new Promise<TelegramListenerCloseReason>((resolve) => {
		onCloseResolve = resolve;
	});

	const botIdStr = chatIdToString(botInfo.id);

	// Helper to check if chat is allowed
	const isChatAllowed = (chatId: number): boolean => {
		if (!allowedChats?.length) return true;
		return allowedChats.some((allowed) => {
			if (typeof allowed === "number") return allowed === chatId;
			return String(allowed) === String(chatId);
		});
	};

	// Helper to build inbound message
	const buildInboundMessage = async (
		ctx: Context,
		isEdited = false,
	): Promise<TelegramInboundMessage | null> => {
		const message = isEdited ? ctx.editedMessage : ctx.message;
		if (!message) return null;

		const chat = message.chat;
		const from = message.from;

		if (!isChatAllowed(chat.id)) {
			if (verbose) {
				logger.debug({ chatId: chat.id }, "message from non-allowed chat, ignoring");
			}
			return null;
		}

		const chatId = chatIdToString(chat.id);
		const body = message.text || message.caption || "";

		// Download media if present
		let mediaPath: string | undefined;
		const mediaType = getMediaTypeFromMessage(message);
		let mediaUrl: string | undefined;
		let mimeType = getMimeTypeFromMessage(message);

		const fileId = getFileIdFromMessage(message);
		if (fileId) {
			try {
				const file = await bot.api.getFile(fileId);
				if (file.file_path) {
					mediaUrl = `https://api.telegram.org/file/bot${bot.token}/${file.file_path}`;
					const response = await fetch(mediaUrl);
					const buffer = Buffer.from(await response.arrayBuffer());
					const saved = await saveMediaBuffer(buffer, mimeType);
					mediaPath = saved.path;
					mimeType = saved.contentType;
				}
			} catch (err) {
				logger.warn({ fileId, error: String(err) }, "failed to download media");
			}
		}

		const inboundMsg: TelegramInboundMessage = {
			id: String(message.message_id),
			chatId: chat.id,
			from: chatId,
			to: botIdStr,
			body,
			pushName: from ? buildPushName(from) : undefined,
			username: from?.username,
			timestamp: message.date * 1000,
			isEdited,
			editedTimestamp: isEdited && message.edit_date ? message.edit_date * 1000 : undefined,
			replyToMessageId: message.reply_to_message?.message_id,
			mediaPath,
			mediaType,
			mediaUrl,
			mimeType,
			sendComposing: async () => {
				await bot.api.sendChatAction(chat.id, "typing");
			},
			reply: async (text: string) => {
				await bot.api.sendMessage(chat.id, text, { parse_mode: "Markdown" });
			},
			sendMedia: async (payload: TelegramMediaPayload) => {
				await sendMediaToChat(bot.api, chat.id, payload);
			},
			raw: message,
		};

		return inboundMsg;
	};

	// Handle text messages
	bot.on("message:text", async (ctx) => {
		const msgId = `${ctx.chat.id}:${ctx.message.message_id}`;
		if (seen.has(msgId)) return;
		seen.add(msgId);

		// Clean up old entries (keep last 1000)
		if (seen.size > 1000) {
			const entries = Array.from(seen);
			for (let i = 0; i < entries.length - 1000; i++) {
				seen.delete(entries[i]);
			}
		}

		const msg = await buildInboundMessage(ctx, false);
		if (!msg) return;

		try {
			await onMessage(msg);
		} catch (err) {
			logger.error({ msgId, error: String(err) }, "message handler failed");
		}
	});

	// Handle media messages
	bot.on(
		["message:photo", "message:document", "message:voice", "message:video", "message:audio"],
		async (ctx) => {
			const msgId = `${ctx.chat.id}:${ctx.message.message_id}`;
			if (seen.has(msgId)) return;
			seen.add(msgId);

			const msg = await buildInboundMessage(ctx, false);
			if (!msg) return;

			try {
				await onMessage(msg);
			} catch (err) {
				logger.error({ msgId, error: String(err) }, "media message handler failed");
			}
		},
	);

	// Handle edited messages
	bot.on("edited_message:text", async (ctx) => {
		const msg = await buildInboundMessage(ctx, true);
		if (!msg) return;

		try {
			await onMessage(msg);
		} catch (err) {
			logger.error({ error: String(err) }, "edited message handler failed");
		}
	});

	return {
		close: async () => {
			await bot.stop();
			onCloseResolve?.({ isTokenRevoked: false });
		},
		onClose,
	};
}

```

File: src/telegram/index.ts (52 tokens)
```
// Telegram provider exports

export * from "./types.js";
export * from "./client.js";
export * from "./inbound.js";
export * from "./outbound.js";
export * from "./reconnect.js";
export * from "./auto-reply.js";

```

File: src/telegram/outbound.ts (1368 tokens)
```
import fs from "node:fs";
import path from "node:path";
import type { Api, Bot } from "grammy";
import { InputFile } from "grammy";
import type { Message } from "grammy/types";

import { getChildLogger } from "../logging.js";
import { stringToChatId } from "../utils.js";
import type { TelegramMediaPayload } from "./types.js";

export type SendMessageOptions = {
	verbose?: boolean;
	mediaUrl?: string;
	mediaPath?: string;
	parseMode?: "Markdown" | "HTML" | "MarkdownV2";
	replyToMessageId?: number;
};

export type SendResult = {
	messageId: string;
	chatId: number;
};

/**
 * Send a message to a Telegram chat.
 */
export async function sendMessageTelegram(
	bot: Bot,
	to: string | number,
	body: string,
	options: SendMessageOptions = {},
): Promise<SendResult> {
	const logger = getChildLogger({ module: "telegram-outbound" });
	const chatId = typeof to === "number" ? to : stringToChatId(to);

	// Send typing indicator
	try {
		await bot.api.sendChatAction(chatId, "typing");
	} catch {
		// Non-fatal
	}

	// Handle media
	const mediaSource = options.mediaPath ?? options.mediaUrl;
	if (mediaSource) {
		const payload = inferMediaPayload(mediaSource, body);
		const result = await sendMediaToChat(bot.api, chatId, payload);
		logger.info({ chatId, messageId: result.message_id, hasMedia: true }, "sent message");
		return { messageId: String(result.message_id), chatId };
	}

	// Send text message
	const result = await bot.api.sendMessage(chatId, body, {
		parse_mode: options.parseMode ?? "Markdown",
		reply_to_message_id: options.replyToMessageId,
	});

	logger.info({ chatId, messageId: result.message_id }, "sent message");
	return { messageId: String(result.message_id), chatId };
}

/**
 * Infer media payload type from file path or URL.
 */
function inferMediaPayload(source: string, caption?: string): TelegramMediaPayload {
	const ext = path.extname(source).toLowerCase();

	if ([".jpg", ".jpeg", ".png", ".gif", ".webp"].includes(ext)) {
		return { type: "photo", source, caption };
	}
	if ([".mp4", ".webm", ".mov", ".avi"].includes(ext)) {
		return { type: "video", source, caption };
	}
	if ([".mp3", ".m4a", ".wav", ".flac"].includes(ext)) {
		return { type: "audio", source, caption };
	}
	if ([".ogg", ".oga"].includes(ext)) {
		return { type: "voice", source, caption };
	}
	if ([".webp", ".tgs"].includes(ext) && !caption) {
		return { type: "sticker", source };
	}

	return { type: "document", source, caption };
}

/**
 * Send media payload to a chat.
 */
export async function sendMediaToChat(
	api: Api,
	chatId: number,
	payload: TelegramMediaPayload,
): Promise<Message> {
	const source = createInputFile(payload.source);

	switch (payload.type) {
		case "photo":
			return api.sendPhoto(chatId, source, { caption: payload.caption });
		case "document":
			return api.sendDocument(chatId, source, { caption: payload.caption });
		case "voice":
			return api.sendVoice(chatId, source, { caption: payload.caption });
		case "video":
			return api.sendVideo(chatId, source, { caption: payload.caption });
		case "audio":
			return api.sendAudio(chatId, source, {
				caption: payload.caption,
				title: payload.title,
				performer: payload.performer,
			});
		case "sticker":
			return api.sendSticker(chatId, source);
		case "animation":
			return api.sendAnimation(chatId, source, { caption: payload.caption });
		default:
			throw new Error(`Unsupported media type: ${(payload as { type: string }).type}`);
	}
}

/**
 * Create InputFile from source (path, URL, or buffer).
 */
export function createInputFile(source: string | Buffer): InputFile {
	if (Buffer.isBuffer(source)) {
		return new InputFile(source);
	}

	// URL
	if (source.startsWith("http://") || source.startsWith("https://")) {
		return new InputFile({ url: source });
	}

	// Local file path
	const absolutePath = path.isAbsolute(source) ? source : path.resolve(source);
	if (fs.existsSync(absolutePath)) {
		return new InputFile(absolutePath);
	}

	// Assume it's a file_id
	return new InputFile(source);
}

/**
 * Send typing indicator (chat action).
 */
export async function sendTypingIndicator(bot: Bot, chatId: number): Promise<void> {
	await bot.api.sendChatAction(chatId, "typing");
}

/**
 * Get bot info.
 */
export async function getBotInfo(bot: Bot) {
	return bot.api.getMe();
}

/**
 * Send a message using just a token (creates temporary bot instance).
 */
export type SendTelegramMessageOptions = {
	token: string;
	chatId: number;
	text?: string;
	mediaPath?: string;
	caption?: string;
};

export type SendTelegramMessageResult = {
	success: boolean;
	messageId?: number;
	error?: string;
};

export async function sendTelegramMessage(
	options: SendTelegramMessageOptions,
): Promise<SendTelegramMessageResult> {
	const { Bot } = await import("grammy");
	const bot = new Bot(options.token);

	try {
		if (options.mediaPath) {
			const payload = inferMediaPayload(options.mediaPath, options.caption ?? options.text);
			const result = await sendMediaToChat(
				bot.api,
				options.chatId,
				payload as TelegramMediaPayload,
			);
			return { success: true, messageId: result.message_id };
		}

		if (options.text) {
			const result = await bot.api.sendMessage(options.chatId, options.text);
			return { success: true, messageId: result.message_id };
		}

		return { success: false, error: "No text or media provided" };
	} catch (err) {
		return { success: false, error: String(err) };
	}
}

```

File: src/telegram/reconnect.ts (501 tokens)
```
import type { TelegramConfig } from "../config/config.js";

export type ReconnectPolicy = {
	initialMs: number;
	maxMs: number;
	factor: number;
	jitter: number;
	maxAttempts: number;
};

export const DEFAULT_RECONNECT_POLICY: ReconnectPolicy = {
	initialMs: 1_000,
	maxMs: 60_000,
	factor: 2.0,
	jitter: 0.3,
	maxAttempts: 0, // 0 = unlimited
};

/**
 * Resolve reconnect policy from config.
 */
export function resolveReconnectPolicy(
	config: { telegram?: TelegramConfig },
	overrides?: Partial<ReconnectPolicy>,
): ReconnectPolicy {
	const cfg = config.telegram?.reconnect;
	return {
		initialMs: overrides?.initialMs ?? cfg?.initialMs ?? DEFAULT_RECONNECT_POLICY.initialMs,
		maxMs: overrides?.maxMs ?? cfg?.maxMs ?? DEFAULT_RECONNECT_POLICY.maxMs,
		factor: overrides?.factor ?? cfg?.factor ?? DEFAULT_RECONNECT_POLICY.factor,
		jitter: overrides?.jitter ?? cfg?.jitter ?? DEFAULT_RECONNECT_POLICY.jitter,
		maxAttempts: overrides?.maxAttempts ?? cfg?.maxAttempts ?? DEFAULT_RECONNECT_POLICY.maxAttempts,
	};
}

/**
 * Compute backoff delay for a given attempt.
 */
export function computeBackoff(policy: ReconnectPolicy, attempt: number): number {
	const base = policy.initialMs * policy.factor ** (attempt - 1);
	const capped = Math.min(base, policy.maxMs);
	const jitterRange = capped * policy.jitter;
	const jitter = (Math.random() - 0.5) * 2 * jitterRange;
	return Math.max(0, Math.round(capped + jitter));
}

/**
 * Sleep with optional abort signal.
 */
export function sleepWithAbort(ms: number, signal?: AbortSignal): Promise<void> {
	return new Promise((resolve, reject) => {
		if (signal?.aborted) {
			reject(new Error("Aborted"));
			return;
		}

		const timer = setTimeout(resolve, ms);

		signal?.addEventListener("abort", () => {
			clearTimeout(timer);
			reject(new Error("Aborted"));
		});
	});
}

/**
 * Generate a unique connection ID.
 */
export function newConnectionId(): string {
	return `conn_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

```

File: src/telegram/types.ts (1154 tokens)
```
import type { Message, User } from "grammy/types";

/**
 * Telegram chat identifier - can be user_id, group chat_id, or channel chat_id
 */
export type TelegramChatId = number | string;

/**
 * Media types supported by Telegram
 */
export type TelegramMediaType =
	| "photo"
	| "document"
	| "voice"
	| "video"
	| "audio"
	| "sticker"
	| "animation";

/**
 * Media payload for outbound messages
 */
export type TelegramMediaPayload =
	| { type: "photo"; source: Buffer | string; caption?: string }
	| { type: "document"; source: Buffer | string; filename?: string; caption?: string }
	| { type: "voice"; source: Buffer | string; caption?: string }
	| { type: "video"; source: Buffer | string; caption?: string }
	| { type: "audio"; source: Buffer | string; caption?: string; title?: string; performer?: string }
	| { type: "sticker"; source: Buffer | string }
	| { type: "animation"; source: Buffer | string; caption?: string };

/**
 * Unified inbound message format
 */
export type TelegramInboundMessage = {
	id: string;
	chatId: number;
	from: string; // Normalized sender ID (tg:123456)
	to: string; // Bot's ID
	body: string; // Text content or caption
	pushName?: string; // User's display name
	username?: string; // @username if available
	timestamp?: number; // Unix timestamp in ms
	isEdited?: boolean;
	editedTimestamp?: number;
	replyToMessageId?: number;

	// Media info (if present)
	mediaPath?: string;
	mediaType?: TelegramMediaType;
	mediaUrl?: string;
	mimeType?: string;

	// Callbacks for responding
	sendComposing: () => Promise<void>;
	reply: (text: string) => Promise<void>;
	sendMedia: (payload: TelegramMediaPayload) => Promise<void>;

	// Raw message for advanced use
	raw?: Message;
};

/**
 * Close reason for the listener
 */
export type TelegramListenerCloseReason = {
	status?: number;
	isTokenRevoked: boolean;
	error?: unknown;
};

/**
 * Connection state
 */
export type TelegramConnectionState = {
	connected: boolean;
	botInfo?: {
		id: number;
		firstName: string;
		username?: string;
	};
	lastPollAt?: number;
	updatesProcessed: number;
};

/**
 * Bot info type
 */
export type BotInfo = {
	id: number;
	is_bot: boolean;
	first_name: string;
	username?: string;
	can_join_groups?: boolean;
	can_read_all_group_messages?: boolean;
	supports_inline_queries?: boolean;
};

/**
 * Build display name from Telegram user info
 */
export function buildPushName(user: User): string {
	const parts = [user.first_name];
	if (user.last_name) parts.push(user.last_name);
	return parts.join(" ");
}

/**
 * Media info extracted from a message
 */
export type MediaInfo = {
	fileId: string;
	type: TelegramMediaType;
	mimeType: string;
};

/**
 * Extract all media info from a message in a single pass.
 */
export function getMediaInfo(message: Message): MediaInfo | undefined {
	if (message.photo?.length) {
		return {
			fileId: message.photo[message.photo.length - 1].file_id,
			type: "photo",
			mimeType: "image/jpeg",
		};
	}
	if (message.document) {
		return {
			fileId: message.document.file_id,
			type: "document",
			mimeType: message.document.mime_type ?? "application/octet-stream",
		};
	}
	if (message.voice) {
		return {
			fileId: message.voice.file_id,
			type: "voice",
			mimeType: message.voice.mime_type ?? "audio/ogg",
		};
	}
	if (message.audio) {
		return {
			fileId: message.audio.file_id,
			type: "audio",
			mimeType: message.audio.mime_type ?? "audio/mpeg",
		};
	}
	if (message.video) {
		return {
			fileId: message.video.file_id,
			type: "video",
			mimeType: message.video.mime_type ?? "video/mp4",
		};
	}
	if (message.sticker) {
		return {
			fileId: message.sticker.file_id,
			type: "sticker",
			mimeType: "image/webp",
		};
	}
	if (message.animation) {
		return {
			fileId: message.animation.file_id,
			type: "animation",
			mimeType: message.animation.mime_type ?? "video/mp4",
		};
	}
	if (message.video_note) {
		return {
			fileId: message.video_note.file_id,
			type: "video",
			mimeType: "video/mp4",
		};
	}
	return undefined;
}

/**
 * Get file ID from various message types
 */
export function getFileIdFromMessage(message: Message): string | undefined {
	return getMediaInfo(message)?.fileId;
}

/**
 * Get media type from message
 */
export function getMediaTypeFromMessage(message: Message): TelegramMediaType | undefined {
	return getMediaInfo(message)?.type;
}

/**
 * Get MIME type from message
 */
export function getMimeTypeFromMessage(message: Message): string | undefined {
	return getMediaInfo(message)?.mimeType;
}

```

File: src/utils.ts (344 tokens)
```
import fs from "node:fs";
import os from "node:os";

export async function ensureDir(dir: string) {
	await fs.promises.mkdir(dir, { recursive: true });
}

export function normalizePath(p: string): string {
	if (!p.startsWith("/")) return `/${p}`;
	return p;
}

/**
 * Convert Telegram chat_id to a normalized string format.
 * Prefixed with "tg:" for clarity and to distinguish from phone numbers.
 */
export function chatIdToString(chatId: number | string): string {
	return `tg:${chatId}`;
}

/**
 * Extract numeric chat_id from our string format.
 */
export function stringToChatId(str: string): number {
	const withoutPrefix = str.replace(/^tg:/, "");
	return Number.parseInt(withoutPrefix, 10);
}

/**
 * Normalize a Telegram identifier (could be chat_id or username).
 */
export function normalizeTelegramId(id: string | number): string {
	if (typeof id === "number") {
		return chatIdToString(id);
	}
	// If already has prefix, return as-is
	if (id.startsWith("tg:")) {
		return id;
	}
	// If it's a numeric string, add prefix
	if (/^\d+$/.test(id)) {
		return `tg:${id}`;
	}
	// If it's a username (starts with @), normalize it
	if (id.startsWith("@")) {
		return id.toLowerCase();
	}
	return id;
}

export function sleep(ms: number) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

export const CONFIG_DIR = `${os.homedir()}/.telclaude`;

```

File: tsconfig.json (203 tokens)
```
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}

```

</files>
